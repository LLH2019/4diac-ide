/*
 * generated by Xtext 2.11.0
 */
package org.eclipse.fordiac.ide.model.structuredtext.services;

import java.util.List;

import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

import com.google.inject.Inject;
import com.google.inject.Singleton;

@Singleton
public class StructuredTextGrammarAccess extends AbstractGrammarElementFinder {
	
	public class StructuredTextAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.StructuredTextAlgorithm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStructuredTextAlgorithmAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cVARKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cLocalVariablesAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cLocalVariablesVar_Decl_InitParserRuleCall_1_1_0_0 = (RuleCall)cLocalVariablesAssignment_1_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Keyword cEND_VARKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStmt_ListParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		
		//StructuredTextAlgorithm:
		//	{StructuredTextAlgorithm} ('VAR' (localVariables+=Var_Decl_Init ';')*
		//	'END_VAR')?
		//	statements=Stmt_List;
		@Override public ParserRule getRule() { return rule; }
		
		//{StructuredTextAlgorithm} ('VAR' (localVariables+=Var_Decl_Init ';')* 'END_VAR')? statements=Stmt_List
		public Group getGroup() { return cGroup; }
		
		//{StructuredTextAlgorithm}
		public Action getStructuredTextAlgorithmAction_0() { return cStructuredTextAlgorithmAction_0; }
		
		//('VAR' (localVariables+=Var_Decl_Init ';')* 'END_VAR')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'VAR'
		public Keyword getVARKeyword_1_0() { return cVARKeyword_1_0; }
		
		//(localVariables+=Var_Decl_Init ';')*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//localVariables+=Var_Decl_Init
		public Assignment getLocalVariablesAssignment_1_1_0() { return cLocalVariablesAssignment_1_1_0; }
		
		//Var_Decl_Init
		public RuleCall getLocalVariablesVar_Decl_InitParserRuleCall_1_1_0_0() { return cLocalVariablesVar_Decl_InitParserRuleCall_1_1_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_1_1() { return cSemicolonKeyword_1_1_1; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_1_2() { return cEND_VARKeyword_1_2; }
		
		//statements=Stmt_List
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_2_0() { return cStatementsStmt_ListParserRuleCall_2_0; }
	}
	public class Var_Decl_InitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Var_Decl_Init");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cConstantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cConstantCONSTANTKeyword_1_0 = (Keyword)cConstantAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTypeDataTypeCrossReference_4_0 = (CrossReference)cTypeAssignment_4.eContents().get(0);
		private final RuleCall cTypeDataTypeType_NameParserRuleCall_4_0_1 = (RuleCall)cTypeDataTypeCrossReference_4_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cArrayAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cArrayLeftSquareBracketKeyword_5_0_0 = (Keyword)cArrayAssignment_5_0.eContents().get(0);
		private final Assignment cArraySizeAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cArraySizeArray_SizeParserRuleCall_5_1_0 = (RuleCall)cArraySizeAssignment_5_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cColonEqualsSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cInitialValueAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cInitialValueConstantParserRuleCall_6_1_0 = (RuleCall)cInitialValueAssignment_6_1.eContents().get(0);
		
		//Var_Decl_Init libraryElement::VarDeclaration:
		//	{LocalVariable} constant?='CONSTANT'? name=ID ':'
		//	type=[datatype::DataType|Type_Name] (array?='[' arraySize=Array_Size ']')? (':=' initialValue=Constant)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{LocalVariable} constant?='CONSTANT'? name=ID ':' type=[datatype::DataType|Type_Name] (array?='[' arraySize=Array_Size
		//']')? (':=' initialValue=Constant)?
		public Group getGroup() { return cGroup; }
		
		//{LocalVariable}
		public Action getLocalVariableAction_0() { return cLocalVariableAction_0; }
		
		//constant?='CONSTANT'?
		public Assignment getConstantAssignment_1() { return cConstantAssignment_1; }
		
		//'CONSTANT'
		public Keyword getConstantCONSTANTKeyword_1_0() { return cConstantCONSTANTKeyword_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//type=[datatype::DataType|Type_Name]
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//[datatype::DataType|Type_Name]
		public CrossReference getTypeDataTypeCrossReference_4_0() { return cTypeDataTypeCrossReference_4_0; }
		
		//Type_Name
		public RuleCall getTypeDataTypeType_NameParserRuleCall_4_0_1() { return cTypeDataTypeType_NameParserRuleCall_4_0_1; }
		
		//(array?='[' arraySize=Array_Size ']')?
		public Group getGroup_5() { return cGroup_5; }
		
		//array?='['
		public Assignment getArrayAssignment_5_0() { return cArrayAssignment_5_0; }
		
		//'['
		public Keyword getArrayLeftSquareBracketKeyword_5_0_0() { return cArrayLeftSquareBracketKeyword_5_0_0; }
		
		//arraySize=Array_Size
		public Assignment getArraySizeAssignment_5_1() { return cArraySizeAssignment_5_1; }
		
		//Array_Size
		public RuleCall getArraySizeArray_SizeParserRuleCall_5_1_0() { return cArraySizeArray_SizeParserRuleCall_5_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_5_2() { return cRightSquareBracketKeyword_5_2; }
		
		//(':=' initialValue=Constant)?
		public Group getGroup_6() { return cGroup_6; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_6_0() { return cColonEqualsSignKeyword_6_0; }
		
		//initialValue=Constant
		public Assignment getInitialValueAssignment_6_1() { return cInitialValueAssignment_6_1; }
		
		//Constant
		public RuleCall getInitialValueConstantParserRuleCall_6_1_0() { return cInitialValueConstantParserRuleCall_6_1_0; }
	}
	public class Stmt_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Stmt_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatementListAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStatementsStmtParserRuleCall_1_0_0 = (RuleCall)cStatementsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		///************************************************************************
		//								statement
		//************************************************************************/ Stmt_List StatementList:
		//	{StatementList} (statements+=Stmt? ';')*;
		@Override public ParserRule getRule() { return rule; }
		
		//{StatementList} (statements+=Stmt? ';')*
		public Group getGroup() { return cGroup; }
		
		//{StatementList}
		public Action getStatementListAction_0() { return cStatementListAction_0; }
		
		//(statements+=Stmt? ';')*
		public Group getGroup_1() { return cGroup_1; }
		
		//statements+=Stmt?
		public Assignment getStatementsAssignment_1_0() { return cStatementsAssignment_1_0; }
		
		//Stmt
		public RuleCall getStatementsStmtParserRuleCall_1_0_0() { return cStatementsStmtParserRuleCall_1_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Stmt");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssign_StmtParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubprog_Ctrl_StmtParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSelection_StmtParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIteration_StmtParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Stmt Statement:
		//	Assign_Stmt | Subprog_Ctrl_Stmt | Selection_Stmt | Iteration_Stmt;
		@Override public ParserRule getRule() { return rule; }
		
		//Assign_Stmt | Subprog_Ctrl_Stmt | Selection_Stmt | Iteration_Stmt
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Assign_Stmt
		public RuleCall getAssign_StmtParserRuleCall_0() { return cAssign_StmtParserRuleCall_0; }
		
		//Subprog_Ctrl_Stmt
		public RuleCall getSubprog_Ctrl_StmtParserRuleCall_1() { return cSubprog_Ctrl_StmtParserRuleCall_1; }
		
		//Selection_Stmt
		public RuleCall getSelection_StmtParserRuleCall_2() { return cSelection_StmtParserRuleCall_2; }
		
		//Iteration_Stmt
		public RuleCall getIteration_StmtParserRuleCall_3() { return cIteration_StmtParserRuleCall_3; }
	}
	public class Assign_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Assign_Stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Assign_Stmt AssignmentStatement:
		//	variable=Variable ':='
		//	expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=Variable ':=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//variable=Variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class Subprog_Ctrl_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Subprog_Ctrl_Stmt");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunc_CallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cSuperStatementAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSUPERKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cReturnStatementAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cRETURNKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//Subprog_Ctrl_Stmt Statement:
		//	Func_Call | {SuperStatement} 'SUPER' '(' ')' | {ReturnStatement} 'RETURN';
		@Override public ParserRule getRule() { return rule; }
		
		//Func_Call | {SuperStatement} 'SUPER' '(' ')' | {ReturnStatement} 'RETURN'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Func_Call
		public RuleCall getFunc_CallParserRuleCall_0() { return cFunc_CallParserRuleCall_0; }
		
		//{SuperStatement} 'SUPER' '(' ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//{SuperStatement}
		public Action getSuperStatementAction_1_0() { return cSuperStatementAction_1_0; }
		
		//'SUPER'
		public Keyword getSUPERKeyword_1_1() { return cSUPERKeyword_1_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
		
		//{ReturnStatement} 'RETURN'
		public Group getGroup_2() { return cGroup_2; }
		
		//{ReturnStatement}
		public Action getReturnStatementAction_2_0() { return cReturnStatementAction_2_0; }
		
		//'RETURN'
		public Keyword getRETURNKeyword_2_1() { return cRETURNKeyword_2_1; }
	}
	public class Selection_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Selection_Stmt");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIF_StmtParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCase_StmtParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Selection_Stmt Statement:
		//	IF_Stmt | Case_Stmt;
		@Override public ParserRule getRule() { return rule; }
		
		//IF_Stmt | Case_Stmt
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IF_Stmt
		public RuleCall getIF_StmtParserRuleCall_0() { return cIF_StmtParserRuleCall_0; }
		
		//Case_Stmt
		public RuleCall getCase_StmtParserRuleCall_1() { return cCase_StmtParserRuleCall_1; }
	}
	public class IF_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.IF_Stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cTHENKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatmentsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatmentsStmt_ListParserRuleCall_3_0 = (RuleCall)cStatmentsAssignment_3.eContents().get(0);
		private final Assignment cElseifAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseifELSIF_ClauseParserRuleCall_4_0 = (RuleCall)cElseifAssignment_4.eContents().get(0);
		private final Assignment cElseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseELSE_ClauseParserRuleCall_5_0 = (RuleCall)cElseAssignment_5.eContents().get(0);
		private final Keyword cEND_IFKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IF_Stmt IfStatement:
		//	'IF' expression=Expression 'THEN'
		//	statments=Stmt_List
		//	elseif+=ELSIF_Clause*
		//	else=ELSE_Clause?
		//	'END_IF';
		@Override public ParserRule getRule() { return rule; }
		
		//'IF' expression=Expression 'THEN' statments=Stmt_List elseif+=ELSIF_Clause* else=ELSE_Clause? 'END_IF'
		public Group getGroup() { return cGroup; }
		
		//'IF'
		public Keyword getIFKeyword_0() { return cIFKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//'THEN'
		public Keyword getTHENKeyword_2() { return cTHENKeyword_2; }
		
		//statments=Stmt_List
		public Assignment getStatmentsAssignment_3() { return cStatmentsAssignment_3; }
		
		//Stmt_List
		public RuleCall getStatmentsStmt_ListParserRuleCall_3_0() { return cStatmentsStmt_ListParserRuleCall_3_0; }
		
		//elseif+=ELSIF_Clause*
		public Assignment getElseifAssignment_4() { return cElseifAssignment_4; }
		
		//ELSIF_Clause
		public RuleCall getElseifELSIF_ClauseParserRuleCall_4_0() { return cElseifELSIF_ClauseParserRuleCall_4_0; }
		
		//else=ELSE_Clause?
		public Assignment getElseAssignment_5() { return cElseAssignment_5; }
		
		//ELSE_Clause
		public RuleCall getElseELSE_ClauseParserRuleCall_5_0() { return cElseELSE_ClauseParserRuleCall_5_0; }
		
		//'END_IF'
		public Keyword getEND_IFKeyword_6() { return cEND_IFKeyword_6; }
	}
	public class ELSIF_ClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.ELSIF_Clause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cELSIFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cTHENKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStmt_ListParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		
		//ELSIF_Clause ElseIfClause:
		//	'ELSIF' expression=Expression 'THEN'
		//	statements=Stmt_List;
		@Override public ParserRule getRule() { return rule; }
		
		//'ELSIF' expression=Expression 'THEN' statements=Stmt_List
		public Group getGroup() { return cGroup; }
		
		//'ELSIF'
		public Keyword getELSIFKeyword_0() { return cELSIFKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//'THEN'
		public Keyword getTHENKeyword_2() { return cTHENKeyword_2; }
		
		//statements=Stmt_List
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_3_0() { return cStatementsStmt_ListParserRuleCall_3_0; }
	}
	public class ELSE_ClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.ELSE_Clause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cELSEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStmt_ListParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		
		//ELSE_Clause ElseClause:
		//	'ELSE'
		//	statements=Stmt_List;
		@Override public ParserRule getRule() { return rule; }
		
		//'ELSE' statements=Stmt_List
		public Group getGroup() { return cGroup; }
		
		//'ELSE'
		public Keyword getELSEKeyword_0() { return cELSEKeyword_0; }
		
		//statements=Stmt_List
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_1_0() { return cStatementsStmt_ListParserRuleCall_1_0; }
	}
	public class Case_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Case_Stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCASEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cOFKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCaseCase_SelectionParserRuleCall_3_0 = (RuleCall)cCaseAssignment_3.eContents().get(0);
		private final Assignment cElseAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseELSE_ClauseParserRuleCall_4_0 = (RuleCall)cElseAssignment_4.eContents().get(0);
		private final Keyword cEND_CASEKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Case_Stmt CaseStatement:
		//	'CASE' expression=Expression 'OF'
		//	case+=Case_Selection+
		//	else=ELSE_Clause?
		//	'END_CASE';
		@Override public ParserRule getRule() { return rule; }
		
		//'CASE' expression=Expression 'OF' case+=Case_Selection+ else=ELSE_Clause? 'END_CASE'
		public Group getGroup() { return cGroup; }
		
		//'CASE'
		public Keyword getCASEKeyword_0() { return cCASEKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//'OF'
		public Keyword getOFKeyword_2() { return cOFKeyword_2; }
		
		//case+=Case_Selection+
		public Assignment getCaseAssignment_3() { return cCaseAssignment_3; }
		
		//Case_Selection
		public RuleCall getCaseCase_SelectionParserRuleCall_3_0() { return cCaseCase_SelectionParserRuleCall_3_0; }
		
		//else=ELSE_Clause?
		public Assignment getElseAssignment_4() { return cElseAssignment_4; }
		
		//ELSE_Clause
		public RuleCall getElseELSE_ClauseParserRuleCall_4_0() { return cElseELSE_ClauseParserRuleCall_4_0; }
		
		//'END_CASE'
		public Keyword getEND_CASEKeyword_5() { return cEND_CASEKeyword_5; }
	}
	public class Case_SelectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Case_Selection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCaseAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCaseConstantParserRuleCall_0_0 = (RuleCall)cCaseAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCaseAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCaseConstantParserRuleCall_1_1_0 = (RuleCall)cCaseAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStmt_ListParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		
		//Case_Selection CaseClause:
		//	case+=Constant (',' case+=Constant)* ':' //only allow explicit constants here
		//	statements=Stmt_List;
		@Override public ParserRule getRule() { return rule; }
		
		//case+=Constant (',' case+=Constant)* ':' //only allow explicit constants here
		//statements=Stmt_List
		public Group getGroup() { return cGroup; }
		
		//case+=Constant
		public Assignment getCaseAssignment_0() { return cCaseAssignment_0; }
		
		//Constant
		public RuleCall getCaseConstantParserRuleCall_0_0() { return cCaseConstantParserRuleCall_0_0; }
		
		//(',' case+=Constant)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//case+=Constant
		public Assignment getCaseAssignment_1_1() { return cCaseAssignment_1_1; }
		
		//Constant
		public RuleCall getCaseConstantParserRuleCall_1_1_0() { return cCaseConstantParserRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		////only allow explicit constants here
		//statements=Stmt_List
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_3_0() { return cStatementsStmt_ListParserRuleCall_3_0; }
	}
	public class Iteration_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Iteration_Stmt");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFor_StmtParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhile_StmtParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRepeat_StmtParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cExitStatementAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cEXITKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cContinueStatementAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cCONTINUEKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		
		//Iteration_Stmt Statement:
		//	For_Stmt | While_Stmt | Repeat_Stmt | {ExitStatement} 'EXIT' | {ContinueStatement} 'CONTINUE';
		@Override public ParserRule getRule() { return rule; }
		
		//For_Stmt | While_Stmt | Repeat_Stmt | {ExitStatement} 'EXIT' | {ContinueStatement} 'CONTINUE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//For_Stmt
		public RuleCall getFor_StmtParserRuleCall_0() { return cFor_StmtParserRuleCall_0; }
		
		//While_Stmt
		public RuleCall getWhile_StmtParserRuleCall_1() { return cWhile_StmtParserRuleCall_1; }
		
		//Repeat_Stmt
		public RuleCall getRepeat_StmtParserRuleCall_2() { return cRepeat_StmtParserRuleCall_2; }
		
		//{ExitStatement} 'EXIT'
		public Group getGroup_3() { return cGroup_3; }
		
		//{ExitStatement}
		public Action getExitStatementAction_3_0() { return cExitStatementAction_3_0; }
		
		//'EXIT'
		public Keyword getEXITKeyword_3_1() { return cEXITKeyword_3_1; }
		
		//{ContinueStatement} 'CONTINUE'
		public Group getGroup_4() { return cGroup_4; }
		
		//{ContinueStatement}
		public Action getContinueStatementAction_4_0() { return cContinueStatementAction_4_0; }
		
		//'CONTINUE'
		public Keyword getCONTINUEKeyword_4_1() { return cCONTINUEKeyword_4_1; }
	}
	public class For_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.For_Stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFORKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVariable_PrimaryParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFromAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFromExpressionParserRuleCall_3_0 = (RuleCall)cFromAssignment_3.eContents().get(0);
		private final Keyword cTOKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cToAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cToExpressionParserRuleCall_5_0 = (RuleCall)cToAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cBYKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cByAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cByExpressionParserRuleCall_6_1_0 = (RuleCall)cByAssignment_6_1.eContents().get(0);
		private final Keyword cDOKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cStatementsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cStatementsStmt_ListParserRuleCall_8_0 = (RuleCall)cStatementsAssignment_8.eContents().get(0);
		private final Keyword cEND_FORKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//For_Stmt ForStatement:
		//	'FOR' variable=Variable_Primary ':=' from=Expression 'TO' to=Expression ('BY' by=Expression)? 'DO'
		//	statements=Stmt_List
		//	'END_FOR';
		@Override public ParserRule getRule() { return rule; }
		
		//'FOR' variable=Variable_Primary ':=' from=Expression 'TO' to=Expression ('BY' by=Expression)? 'DO' statements=Stmt_List
		//'END_FOR'
		public Group getGroup() { return cGroup; }
		
		//'FOR'
		public Keyword getFORKeyword_0() { return cFORKeyword_0; }
		
		//variable=Variable_Primary
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//Variable_Primary
		public RuleCall getVariableVariable_PrimaryParserRuleCall_1_0() { return cVariableVariable_PrimaryParserRuleCall_1_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }
		
		//from=Expression
		public Assignment getFromAssignment_3() { return cFromAssignment_3; }
		
		//Expression
		public RuleCall getFromExpressionParserRuleCall_3_0() { return cFromExpressionParserRuleCall_3_0; }
		
		//'TO'
		public Keyword getTOKeyword_4() { return cTOKeyword_4; }
		
		//to=Expression
		public Assignment getToAssignment_5() { return cToAssignment_5; }
		
		//Expression
		public RuleCall getToExpressionParserRuleCall_5_0() { return cToExpressionParserRuleCall_5_0; }
		
		//('BY' by=Expression)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'BY'
		public Keyword getBYKeyword_6_0() { return cBYKeyword_6_0; }
		
		//by=Expression
		public Assignment getByAssignment_6_1() { return cByAssignment_6_1; }
		
		//Expression
		public RuleCall getByExpressionParserRuleCall_6_1_0() { return cByExpressionParserRuleCall_6_1_0; }
		
		//'DO'
		public Keyword getDOKeyword_7() { return cDOKeyword_7; }
		
		//statements=Stmt_List
		public Assignment getStatementsAssignment_8() { return cStatementsAssignment_8; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_8_0() { return cStatementsStmt_ListParserRuleCall_8_0; }
		
		//'END_FOR'
		public Keyword getEND_FORKeyword_9() { return cEND_FORKeyword_9; }
	}
	public class While_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.While_Stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWHILEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cDOKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStmt_ListParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Keyword cEND_WHILEKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//While_Stmt WhileStatement:
		//	'WHILE' expression=Expression 'DO'
		//	statements=Stmt_List
		//	'END_WHILE';
		@Override public ParserRule getRule() { return rule; }
		
		//'WHILE' expression=Expression 'DO' statements=Stmt_List 'END_WHILE'
		public Group getGroup() { return cGroup; }
		
		//'WHILE'
		public Keyword getWHILEKeyword_0() { return cWHILEKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//'DO'
		public Keyword getDOKeyword_2() { return cDOKeyword_2; }
		
		//statements=Stmt_List
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_3_0() { return cStatementsStmt_ListParserRuleCall_3_0; }
		
		//'END_WHILE'
		public Keyword getEND_WHILEKeyword_4() { return cEND_WHILEKeyword_4; }
	}
	public class Repeat_StmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Repeat_Stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cREPEATKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStmt_ListParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		private final Keyword cUNTILKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cEND_REPEATKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Repeat_Stmt RepeatStatement:
		//	'REPEAT'
		//	statements=Stmt_List
		//	'UNTIL' expression=Expression
		//	'END_REPEAT';
		@Override public ParserRule getRule() { return rule; }
		
		//'REPEAT' statements=Stmt_List 'UNTIL' expression=Expression 'END_REPEAT'
		public Group getGroup() { return cGroup; }
		
		//'REPEAT'
		public Keyword getREPEATKeyword_0() { return cREPEATKeyword_0; }
		
		//statements=Stmt_List
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//Stmt_List
		public RuleCall getStatementsStmt_ListParserRuleCall_1_0() { return cStatementsStmt_ListParserRuleCall_1_0; }
		
		//'UNTIL'
		public Keyword getUNTILKeyword_2() { return cUNTILKeyword_2; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
		
		//'END_REPEAT'
		public Keyword getEND_REPEATKeyword_4() { return cEND_REPEATKeyword_4; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Expression");
		private final RuleCall cOr_ExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///************************************************************************
		//								expression
		//************************************************************************/ Expression:
		//	Or_Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//Or_Expression
		public RuleCall getOr_ExpressionParserRuleCall() { return cOr_ExpressionParserRuleCall; }
	}
	public class Or_ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Or_Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXor_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorOr_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXor_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or_Expression Expression:
		//	Xor_Expr ({BinaryExpression.left=current} operator=Or_Operator right=Xor_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Xor_Expr ({BinaryExpression.left=current} operator=Or_Operator right=Xor_Expr)*
		public Group getGroup() { return cGroup; }
		
		//Xor_Expr
		public RuleCall getXor_ExprParserRuleCall_0() { return cXor_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Or_Operator right=Xor_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Or_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Or_Operator
		public RuleCall getOperatorOr_OperatorEnumRuleCall_1_1_0() { return cOperatorOr_OperatorEnumRuleCall_1_1_0; }
		
		//right=Xor_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor_Expr
		public RuleCall getRightXor_ExprParserRuleCall_1_2_0() { return cRightXor_ExprParserRuleCall_1_2_0; }
	}
	public class Xor_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Xor_Expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAnd_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorXor_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAnd_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor_Expr Expression:
		//	And_Expr ({BinaryExpression.left=current} operator=Xor_Operator right=And_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And_Expr ({BinaryExpression.left=current} operator=Xor_Operator right=And_Expr)*
		public Group getGroup() { return cGroup; }
		
		//And_Expr
		public RuleCall getAnd_ExprParserRuleCall_0() { return cAnd_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Xor_Operator right=And_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Xor_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Xor_Operator
		public RuleCall getOperatorXor_OperatorEnumRuleCall_1_1_0() { return cOperatorXor_OperatorEnumRuleCall_1_1_0; }
		
		//right=And_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And_Expr
		public RuleCall getRightAnd_ExprParserRuleCall_1_2_0() { return cRightAnd_ExprParserRuleCall_1_2_0; }
	}
	public class And_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.And_Expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCompare_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAnd_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightCompare_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And_Expr Expression:
		//	Compare_Expr ({BinaryExpression.left=current} operator=And_Operator right=Compare_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Compare_Expr ({BinaryExpression.left=current} operator=And_Operator right=Compare_Expr)*
		public Group getGroup() { return cGroup; }
		
		//Compare_Expr
		public RuleCall getCompare_ExprParserRuleCall_0() { return cCompare_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=And_Operator right=Compare_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=And_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//And_Operator
		public RuleCall getOperatorAnd_OperatorEnumRuleCall_1_1_0() { return cOperatorAnd_OperatorEnumRuleCall_1_1_0; }
		
		//right=Compare_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Compare_Expr
		public RuleCall getRightCompare_ExprParserRuleCall_1_2_0() { return cRightCompare_ExprParserRuleCall_1_2_0; }
	}
	public class Compare_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Compare_Expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqu_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorCompare_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqu_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Compare_Expr Expression:
		//	Equ_Expr ({BinaryExpression.left=current} operator=Compare_Operator right=Equ_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Equ_Expr ({BinaryExpression.left=current} operator=Compare_Operator right=Equ_Expr)*
		public Group getGroup() { return cGroup; }
		
		//Equ_Expr
		public RuleCall getEqu_ExprParserRuleCall_0() { return cEqu_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Compare_Operator right=Equ_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Compare_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Compare_Operator
		public RuleCall getOperatorCompare_OperatorEnumRuleCall_1_1_0() { return cOperatorCompare_OperatorEnumRuleCall_1_1_0; }
		
		//right=Equ_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Equ_Expr
		public RuleCall getRightEqu_ExprParserRuleCall_1_2_0() { return cRightEqu_ExprParserRuleCall_1_2_0; }
	}
	public class Equ_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Equ_Expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdd_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorEqu_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdd_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equ_Expr Expression:
		//	Add_Expr ({BinaryExpression.left=current} operator=Equ_Operator right=Add_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Add_Expr ({BinaryExpression.left=current} operator=Equ_Operator right=Add_Expr)*
		public Group getGroup() { return cGroup; }
		
		//Add_Expr
		public RuleCall getAdd_ExprParserRuleCall_0() { return cAdd_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Equ_Operator right=Add_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Equ_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Equ_Operator
		public RuleCall getOperatorEqu_OperatorEnumRuleCall_1_1_0() { return cOperatorEqu_OperatorEnumRuleCall_1_1_0; }
		
		//right=Add_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Add_Expr
		public RuleCall getRightAdd_ExprParserRuleCall_1_2_0() { return cRightAdd_ExprParserRuleCall_1_2_0; }
	}
	public class Add_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Add_Expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTermParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdd_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTermParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Add_Expr Expression:
		//	Term ({BinaryExpression.left=current} operator=Add_Operator right=Term)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Term ({BinaryExpression.left=current} operator=Add_Operator right=Term)*
		public Group getGroup() { return cGroup; }
		
		//Term
		public RuleCall getTermParserRuleCall_0() { return cTermParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Add_Operator right=Term)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Add_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Add_Operator
		public RuleCall getOperatorAdd_OperatorEnumRuleCall_1_1_0() { return cOperatorAdd_OperatorEnumRuleCall_1_1_0; }
		
		//right=Term
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_1_2_0() { return cRightTermParserRuleCall_1_2_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPower_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorTerm_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPower_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Term Expression:
		//	Power_Expr ({BinaryExpression.left=current} operator=Term_Operator right=Power_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Power_Expr ({BinaryExpression.left=current} operator=Term_Operator right=Power_Expr)*
		public Group getGroup() { return cGroup; }
		
		//Power_Expr
		public RuleCall getPower_ExprParserRuleCall_0() { return cPower_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Term_Operator right=Power_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Term_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Term_Operator
		public RuleCall getOperatorTerm_OperatorEnumRuleCall_1_1_0() { return cOperatorTerm_OperatorEnumRuleCall_1_1_0; }
		
		//right=Power_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Power_Expr
		public RuleCall getRightPower_ExprParserRuleCall_1_2_0() { return cRightPower_ExprParserRuleCall_1_2_0; }
	}
	public class Power_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Power_Expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnary_ExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorPower_OperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUnary_ExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Power_Expr Expression:
		//	Unary_Expr ({BinaryExpression.left=current} operator=Power_Operator right=Unary_Expr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Unary_Expr ({BinaryExpression.left=current} operator=Power_Operator right=Unary_Expr)*
		public Group getGroup() { return cGroup; }
		
		//Unary_Expr
		public RuleCall getUnary_ExprParserRuleCall_0() { return cUnary_ExprParserRuleCall_0; }
		
		//({BinaryExpression.left=current} operator=Power_Operator right=Unary_Expr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//operator=Power_Operator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Power_Operator
		public RuleCall getOperatorPower_OperatorEnumRuleCall_1_1_0() { return cOperatorPower_OperatorEnumRuleCall_1_1_0; }
		
		//right=Unary_Expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Unary_Expr
		public RuleCall getRightUnary_ExprParserRuleCall_1_2_0() { return cRightUnary_ExprParserRuleCall_1_2_0; }
	}
	public class Unary_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Unary_Expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOperatorUnary_OperatorEnumRuleCall_0_1_0 = (RuleCall)cOperatorAssignment_0_1.eContents().get(0);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionPrimary_ExprParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cPrimary_ExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Unary_Expr Expression:
		//	{UnaryExpression} operator=Unary_Operator expression=Primary_Expr | Primary_Expr | Constant // handle Constant here to avoid ambiguity with '+' and '-' operators
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{UnaryExpression} operator=Unary_Operator expression=Primary_Expr | Primary_Expr | Constant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{UnaryExpression} operator=Unary_Operator expression=Primary_Expr
		public Group getGroup_0() { return cGroup_0; }
		
		//{UnaryExpression}
		public Action getUnaryExpressionAction_0_0() { return cUnaryExpressionAction_0_0; }
		
		//operator=Unary_Operator
		public Assignment getOperatorAssignment_0_1() { return cOperatorAssignment_0_1; }
		
		//Unary_Operator
		public RuleCall getOperatorUnary_OperatorEnumRuleCall_0_1_0() { return cOperatorUnary_OperatorEnumRuleCall_0_1_0; }
		
		//expression=Primary_Expr
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }
		
		//Primary_Expr
		public RuleCall getExpressionPrimary_ExprParserRuleCall_0_2_0() { return cExpressionPrimary_ExprParserRuleCall_0_2_0; }
		
		//Primary_Expr
		public RuleCall getPrimary_ExprParserRuleCall_1() { return cPrimary_ExprParserRuleCall_1; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_2() { return cConstantParserRuleCall_2; }
	}
	public class Primary_ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Primary_Expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunc_CallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//Primary_Expr Expression:
		//	Variable | Func_Call | /*Ref_Value |*/ '(' Expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//Variable | Func_Call | /*Ref_Value |*/ '(' Expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_0() { return cVariableParserRuleCall_0; }
		
		//Func_Call
		public RuleCall getFunc_CallParserRuleCall_1() { return cFunc_CallParserRuleCall_1; }
		
		///*Ref_Value |*/ '(' Expression ')'
		public Group getGroup_2() { return cGroup_2; }
		
		///*Ref_Value |*/ '('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2_1() { return cExpressionParserRuleCall_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}
	public class Func_CallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Func_Call");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFuncAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cFuncAlternatives_0_0 = (Alternatives)cFuncAssignment_0.eContents().get(0);
		private final RuleCall cFuncIDTerminalRuleCall_0_0_0 = (RuleCall)cFuncAlternatives_0_0.eContents().get(0);
		private final Keyword cFuncTIMEKeyword_0_0_1 = (Keyword)cFuncAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgsParam_AssignParserRuleCall_2_0_0 = (RuleCall)cArgsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgsParam_AssignParserRuleCall_2_1_1_0 = (RuleCall)cArgsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Func_Call Call:
		//	func=(ID | 'TIME') // also allow 'TIME' as function name
		//	'(' (args+=Param_Assign (',' args+=Param_Assign)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//func=(ID | 'TIME') // also allow 'TIME' as function name
		//'(' (args+=Param_Assign (',' args+=Param_Assign)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//func=(ID | 'TIME')
		public Assignment getFuncAssignment_0() { return cFuncAssignment_0; }
		
		//(ID | 'TIME')
		public Alternatives getFuncAlternatives_0_0() { return cFuncAlternatives_0_0; }
		
		//ID
		public RuleCall getFuncIDTerminalRuleCall_0_0_0() { return cFuncIDTerminalRuleCall_0_0_0; }
		
		//'TIME'
		public Keyword getFuncTIMEKeyword_0_0_1() { return cFuncTIMEKeyword_0_0_1; }
		
		//// also allow 'TIME' as function name
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(args+=Param_Assign (',' args+=Param_Assign)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//args+=Param_Assign
		public Assignment getArgsAssignment_2_0() { return cArgsAssignment_2_0; }
		
		//Param_Assign
		public RuleCall getArgsParam_AssignParserRuleCall_2_0_0() { return cArgsParam_AssignParserRuleCall_2_0_0; }
		
		//(',' args+=Param_Assign)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//args+=Param_Assign
		public Assignment getArgsAssignment_2_1_1() { return cArgsAssignment_2_1_1; }
		
		//Param_Assign
		public RuleCall getArgsParam_AssignParserRuleCall_2_1_1_0() { return cArgsParam_AssignParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Param_AssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Param_Assign");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParam_Assign_InParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParam_Assign_OutParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Param_Assign Argument:
		//	Param_Assign_In | Param_Assign_Out;
		@Override public ParserRule getRule() { return rule; }
		
		//Param_Assign_In | Param_Assign_Out
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Param_Assign_In
		public RuleCall getParam_Assign_InParserRuleCall_0() { return cParam_Assign_InParserRuleCall_0; }
		
		///*Ref_Assign |*/ Param_Assign_Out
		public RuleCall getParam_Assign_OutParserRuleCall_1() { return cParam_Assign_OutParserRuleCall_1; }
	}
	public class Param_Assign_InElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Param_Assign_In");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cVarIDTerminalRuleCall_0_0_0 = (RuleCall)cVarAssignment_0_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//Param_Assign_In InArgument:
		//	(var=ID ':=')? expr=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//(var=ID ':=')? expr=Expression
		public Group getGroup() { return cGroup; }
		
		//(var=ID ':=')?
		public Group getGroup_0() { return cGroup_0; }
		
		//var=ID
		public Assignment getVarAssignment_0_0() { return cVarAssignment_0_0; }
		
		//ID
		public RuleCall getVarIDTerminalRuleCall_0_0_0() { return cVarIDTerminalRuleCall_0_0_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_0_1() { return cColonEqualsSignKeyword_0_1; }
		
		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}
	public class Param_Assign_OutElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Param_Assign_Out");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNotAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNotNOTKeyword_0_0 = (Keyword)cNotAssignment_0.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarIDTerminalRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExprVariableParserRuleCall_3_0 = (RuleCall)cExprAssignment_3.eContents().get(0);
		
		//Param_Assign_Out OutArgument:
		//	not?='NOT'? var=ID '=>' expr=Variable;
		@Override public ParserRule getRule() { return rule; }
		
		//not?='NOT'? var=ID '=>' expr=Variable
		public Group getGroup() { return cGroup; }
		
		//not?='NOT'?
		public Assignment getNotAssignment_0() { return cNotAssignment_0; }
		
		//'NOT'
		public Keyword getNotNOTKeyword_0_0() { return cNotNOTKeyword_0_0; }
		
		//var=ID
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }
		
		//ID
		public RuleCall getVarIDTerminalRuleCall_1_0() { return cVarIDTerminalRuleCall_1_0; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_2() { return cEqualsSignGreaterThanSignKeyword_2; }
		
		//expr=Variable
		public Assignment getExprAssignment_3() { return cExprAssignment_3; }
		
		//Variable
		public RuleCall getExprVariableParserRuleCall_3_0() { return cExprVariableParserRuleCall_3_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Variable");
		private final RuleCall cVariable_SubscriptParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Variable:
		//	Variable_Subscript;
		@Override public ParserRule getRule() { return rule; }
		
		//Variable_Subscript
		public RuleCall getVariable_SubscriptParserRuleCall() { return cVariable_SubscriptParserRuleCall; }
	}
	public class Variable_SubscriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Variable_Subscript");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cVariable_PrimaryParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cVariable_AdapterParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArrayVariableArrayAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cIndexAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIndexExpressionParserRuleCall_1_2_0 = (RuleCall)cIndexAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cIndexAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cIndexExpressionParserRuleCall_1_3_1_0 = (RuleCall)cIndexAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//Variable_Subscript Variable:
		//	(Variable_Primary | Variable_Adapter) ({ArrayVariable.array=current} '[' index+=Expression (',' index+=Expression)*
		//	']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//(Variable_Primary | Variable_Adapter) ({ArrayVariable.array=current} '[' index+=Expression (',' index+=Expression)*
		//']')?
		public Group getGroup() { return cGroup; }
		
		//Variable_Primary | Variable_Adapter
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//Variable_Primary
		public RuleCall getVariable_PrimaryParserRuleCall_0_0() { return cVariable_PrimaryParserRuleCall_0_0; }
		
		//Variable_Adapter
		public RuleCall getVariable_AdapterParserRuleCall_0_1() { return cVariable_AdapterParserRuleCall_0_1; }
		
		//({ArrayVariable.array=current} '[' index+=Expression (',' index+=Expression)* ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//{ArrayVariable.array=current}
		public Action getArrayVariableArrayAction_1_0() { return cArrayVariableArrayAction_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//index+=Expression
		public Assignment getIndexAssignment_1_2() { return cIndexAssignment_1_2; }
		
		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_2_0() { return cIndexExpressionParserRuleCall_1_2_0; }
		
		//(',' index+=Expression)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//index+=Expression
		public Assignment getIndexAssignment_1_3_1() { return cIndexAssignment_1_3_1; }
		
		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_3_1_0() { return cIndexExpressionParserRuleCall_1_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
	}
	public class Variable_AdapterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Variable_Adapter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAdapterVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cAdapterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cAdapterAdapterDeclarationCrossReference_1_0 = (CrossReference)cAdapterAssignment_1.eContents().get(0);
		private final RuleCall cAdapterAdapterDeclarationAdapter_NameParserRuleCall_1_0_1 = (RuleCall)cAdapterAdapterDeclarationCrossReference_1_0.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVarAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cVarVarDeclarationCrossReference_3_0 = (CrossReference)cVarAssignment_3.eContents().get(0);
		private final RuleCall cVarVarDeclarationVariable_NameParserRuleCall_3_0_1 = (RuleCall)cVarVarDeclarationCrossReference_3_0.eContents().get(1);
		
		//Variable_Adapter Variable:
		//	{AdapterVariable} adapter=[libraryElement::AdapterDeclaration|Adapter_Name] '.'
		//	var=[libraryElement::VarDeclaration|Variable_Name];
		@Override public ParserRule getRule() { return rule; }
		
		//{AdapterVariable} adapter=[libraryElement::AdapterDeclaration|Adapter_Name] '.'
		//var=[libraryElement::VarDeclaration|Variable_Name]
		public Group getGroup() { return cGroup; }
		
		//{AdapterVariable}
		public Action getAdapterVariableAction_0() { return cAdapterVariableAction_0; }
		
		//adapter=[libraryElement::AdapterDeclaration|Adapter_Name]
		public Assignment getAdapterAssignment_1() { return cAdapterAssignment_1; }
		
		//[libraryElement::AdapterDeclaration|Adapter_Name]
		public CrossReference getAdapterAdapterDeclarationCrossReference_1_0() { return cAdapterAdapterDeclarationCrossReference_1_0; }
		
		//Adapter_Name
		public RuleCall getAdapterAdapterDeclarationAdapter_NameParserRuleCall_1_0_1() { return cAdapterAdapterDeclarationAdapter_NameParserRuleCall_1_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//var=[libraryElement::VarDeclaration|Variable_Name]
		public Assignment getVarAssignment_3() { return cVarAssignment_3; }
		
		//[libraryElement::VarDeclaration|Variable_Name]
		public CrossReference getVarVarDeclarationCrossReference_3_0() { return cVarVarDeclarationCrossReference_3_0; }
		
		//Variable_Name
		public RuleCall getVarVarDeclarationVariable_NameParserRuleCall_3_0_1() { return cVarVarDeclarationVariable_NameParserRuleCall_3_0_1; }
	}
	public class Adapter_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Adapter_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Adapter_Name:
		//	ID | 'T' | 'LT' | 'DT';
		@Override public ParserRule getRule() { return rule; }
		
		//ID | 'T' | 'LT' | 'DT'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//'T'
		public Keyword getTKeyword_1() { return cTKeyword_1; }
		
		//'LT'
		public Keyword getLTKeyword_2() { return cLTKeyword_2; }
		
		//'DT'
		public Keyword getDTKeyword_3() { return cDTKeyword_3; }
	}
	public class Variable_PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Variable_Primary");
		private final Assignment cVarAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cVarVarDeclarationCrossReference_0 = (CrossReference)cVarAssignment.eContents().get(0);
		private final RuleCall cVarVarDeclarationVariable_NameParserRuleCall_0_1 = (RuleCall)cVarVarDeclarationCrossReference_0.eContents().get(1);
		
		//Variable_Primary PrimaryVariable:
		//	var=[libraryElement::VarDeclaration|Variable_Name];
		@Override public ParserRule getRule() { return rule; }
		
		//var=[libraryElement::VarDeclaration|Variable_Name]
		public Assignment getVarAssignment() { return cVarAssignment; }
		
		//[libraryElement::VarDeclaration|Variable_Name]
		public CrossReference getVarVarDeclarationCrossReference_0() { return cVarVarDeclarationCrossReference_0; }
		
		//Variable_Name
		public RuleCall getVarVarDeclarationVariable_NameParserRuleCall_0_1() { return cVarVarDeclarationVariable_NameParserRuleCall_0_1; }
	}
	public class Variable_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Variable_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Variable_Name:
		//	ID | 'T' | 'LT' | 'DT';
		@Override public ParserRule getRule() { return rule; }
		
		//ID | 'T' | 'LT' | 'DT'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//'T'
		public Keyword getTKeyword_1() { return cTKeyword_1; }
		
		//'LT'
		public Keyword getLTKeyword_2() { return cLTKeyword_2; }
		
		//'DT'
		public Keyword getDTKeyword_3() { return cDTKeyword_3; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumeric_LiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cChar_LiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTime_LiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBool_LiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		///************************************************************************
		//								literals
		//*************************************************************************/ Constant:
		//	Numeric_Literal | Char_Literal | Time_Literal | Bool_Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Numeric_Literal | Char_Literal | Time_Literal | Bool_Literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Numeric_Literal
		public RuleCall getNumeric_LiteralParserRuleCall_0() { return cNumeric_LiteralParserRuleCall_0; }
		
		//Char_Literal
		public RuleCall getChar_LiteralParserRuleCall_1() { return cChar_LiteralParserRuleCall_1; }
		
		//Time_Literal
		public RuleCall getTime_LiteralParserRuleCall_2() { return cTime_LiteralParserRuleCall_2; }
		
		//Bool_Literal
		public RuleCall getBool_LiteralParserRuleCall_3() { return cBool_LiteralParserRuleCall_3; }
	}
	public class Numeric_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Numeric_Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInt_LiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReal_LiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Numeric_Literal NumericLiteral:
		//	Int_Literal | Real_Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//Int_Literal | Real_Literal
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Int_Literal
		public RuleCall getInt_LiteralParserRuleCall_0() { return cInt_LiteralParserRuleCall_0; }
		
		//Real_Literal
		public RuleCall getReal_LiteralParserRuleCall_1() { return cReal_LiteralParserRuleCall_1; }
	}
	public class Int_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Int_Literal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTypeInt_Type_NameEnumRuleCall_0_0_0 = (RuleCall)cTypeAssignment_0_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueSigned_IntParserRuleCall_1_0_0 = (RuleCall)cValueAlternatives_1_0.eContents().get(0);
		private final RuleCall cValueBINARY_INTTerminalRuleCall_1_0_1 = (RuleCall)cValueAlternatives_1_0.eContents().get(1);
		private final RuleCall cValueOCTAL_INTTerminalRuleCall_1_0_2 = (RuleCall)cValueAlternatives_1_0.eContents().get(2);
		private final RuleCall cValueHEX_INTTerminalRuleCall_1_0_3 = (RuleCall)cValueAlternatives_1_0.eContents().get(3);
		
		//Int_Literal IntLiteral:
		//	(type=Int_Type_Name '#')?
		//	value=(Signed_Int | BINARY_INT | OCTAL_INT | HEX_INT);
		@Override public ParserRule getRule() { return rule; }
		
		//(type=Int_Type_Name '#')? value=(Signed_Int | BINARY_INT | OCTAL_INT | HEX_INT)
		public Group getGroup() { return cGroup; }
		
		//(type=Int_Type_Name '#')?
		public Group getGroup_0() { return cGroup_0; }
		
		//type=Int_Type_Name
		public Assignment getTypeAssignment_0_0() { return cTypeAssignment_0_0; }
		
		//Int_Type_Name
		public RuleCall getTypeInt_Type_NameEnumRuleCall_0_0_0() { return cTypeInt_Type_NameEnumRuleCall_0_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_0_1() { return cNumberSignKeyword_0_1; }
		
		//value=(Signed_Int | BINARY_INT | OCTAL_INT | HEX_INT)
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//(Signed_Int | BINARY_INT | OCTAL_INT | HEX_INT)
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }
		
		//Signed_Int
		public RuleCall getValueSigned_IntParserRuleCall_1_0_0() { return cValueSigned_IntParserRuleCall_1_0_0; }
		
		//BINARY_INT
		public RuleCall getValueBINARY_INTTerminalRuleCall_1_0_1() { return cValueBINARY_INTTerminalRuleCall_1_0_1; }
		
		//OCTAL_INT
		public RuleCall getValueOCTAL_INTTerminalRuleCall_1_0_2() { return cValueOCTAL_INTTerminalRuleCall_1_0_2; }
		
		//HEX_INT
		public RuleCall getValueHEX_INTTerminalRuleCall_1_0_3() { return cValueHEX_INTTerminalRuleCall_1_0_3; }
	}
	public class Signed_IntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Signed_Int");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cUNSIGNED_INTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Signed_Int ecore::ELong:
		//	('+' | '-')? UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//('+' | '-')? UNSIGNED_INT
		public Group getGroup() { return cGroup; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_0() { return cPlusSignKeyword_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall_1() { return cUNSIGNED_INTTerminalRuleCall_1; }
	}
	public class Array_SizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Array_Size");
		private final RuleCall cUNSIGNED_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Array_Size ecore::EInt:
		//	UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall() { return cUNSIGNED_INTTerminalRuleCall; }
	}
	public class Real_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Real_Literal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTypeReal_Type_NameEnumRuleCall_0_0_0 = (RuleCall)cTypeAssignment_0_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueReal_ValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//Real_Literal RealLiteral:
		//	(type=Real_Type_Name '#')?
		//	value=Real_Value;
		@Override public ParserRule getRule() { return rule; }
		
		//(type=Real_Type_Name '#')? value=Real_Value
		public Group getGroup() { return cGroup; }
		
		//(type=Real_Type_Name '#')?
		public Group getGroup_0() { return cGroup_0; }
		
		//type=Real_Type_Name
		public Assignment getTypeAssignment_0_0() { return cTypeAssignment_0_0; }
		
		//Real_Type_Name
		public RuleCall getTypeReal_Type_NameEnumRuleCall_0_0_0() { return cTypeReal_Type_NameEnumRuleCall_0_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_0_1() { return cNumberSignKeyword_0_1; }
		
		//value=Real_Value
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Real_Value
		public RuleCall getValueReal_ValueParserRuleCall_1_0() { return cValueReal_ValueParserRuleCall_1_0; }
	}
	public class Real_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Real_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSigned_IntParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cUNSIGNED_INTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cSigned_IntParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//Real_Value ecore::EDouble:
		//	Signed_Int '.' UNSIGNED_INT ('E' Signed_Int)?;
		@Override public ParserRule getRule() { return rule; }
		
		//Signed_Int '.' UNSIGNED_INT ('E' Signed_Int)?
		public Group getGroup() { return cGroup; }
		
		//Signed_Int
		public RuleCall getSigned_IntParserRuleCall_0() { return cSigned_IntParserRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall_2() { return cUNSIGNED_INTTerminalRuleCall_2; }
		
		//('E' Signed_Int)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'E'
		public Keyword getEKeyword_3_0() { return cEKeyword_3_0; }
		
		//Signed_Int
		public RuleCall getSigned_IntParserRuleCall_3_1() { return cSigned_IntParserRuleCall_3_1; }
	}
	public class Bool_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Bool_Literal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTypeBool_Type_NameEnumRuleCall_0_0_0 = (RuleCall)cTypeAssignment_0_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBool_ValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//Bool_Literal BoolLiteral:
		//	(type=Bool_Type_Name '#')?
		//	value=Bool_Value;
		@Override public ParserRule getRule() { return rule; }
		
		//(type=Bool_Type_Name '#')? value=Bool_Value
		public Group getGroup() { return cGroup; }
		
		//(type=Bool_Type_Name '#')?
		public Group getGroup_0() { return cGroup_0; }
		
		//type=Bool_Type_Name
		public Assignment getTypeAssignment_0_0() { return cTypeAssignment_0_0; }
		
		//Bool_Type_Name
		public RuleCall getTypeBool_Type_NameEnumRuleCall_0_0_0() { return cTypeBool_Type_NameEnumRuleCall_0_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_0_1() { return cNumberSignKeyword_0_1; }
		
		//value=Bool_Value
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Bool_Value
		public RuleCall getValueBool_ValueParserRuleCall_1_0() { return cValueBool_ValueParserRuleCall_1_0; }
	}
	public class Bool_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Bool_Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFALSEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTRUEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Bool_Value ecore::EBoolean:
		//	'FALSE' | 'TRUE' // cannot distinguish '0' and '1' from Int_Literal
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'FALSE' | 'TRUE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_0() { return cFALSEKeyword_0; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_1() { return cTRUEKeyword_1; }
	}
	public class Char_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Char_Literal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTypeString_Type_NameEnumRuleCall_0_0_0 = (RuleCall)cTypeAssignment_0_0.eContents().get(0);
		private final Assignment cLengthAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cLengthUNSIGNED_INTTerminalRuleCall_0_1_0 = (RuleCall)cLengthAssignment_0_1.eContents().get(0);
		private final Keyword cNumberSignKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueS_BYTE_CHAR_STRTerminalRuleCall_1_0_0 = (RuleCall)cValueAlternatives_1_0.eContents().get(0);
		private final RuleCall cValueD_BYTE_CHAR_STRTerminalRuleCall_1_0_1 = (RuleCall)cValueAlternatives_1_0.eContents().get(1);
		
		//Char_Literal StringLiteral:
		//	(type=String_Type_Name length=UNSIGNED_INT? '#')?
		//	value=(S_BYTE_CHAR_STR | D_BYTE_CHAR_STR);
		@Override public ParserRule getRule() { return rule; }
		
		//(type=String_Type_Name length=UNSIGNED_INT? '#')? value=(S_BYTE_CHAR_STR | D_BYTE_CHAR_STR)
		public Group getGroup() { return cGroup; }
		
		//(type=String_Type_Name length=UNSIGNED_INT? '#')?
		public Group getGroup_0() { return cGroup_0; }
		
		//type=String_Type_Name
		public Assignment getTypeAssignment_0_0() { return cTypeAssignment_0_0; }
		
		//String_Type_Name
		public RuleCall getTypeString_Type_NameEnumRuleCall_0_0_0() { return cTypeString_Type_NameEnumRuleCall_0_0_0; }
		
		//length=UNSIGNED_INT?
		public Assignment getLengthAssignment_0_1() { return cLengthAssignment_0_1; }
		
		//UNSIGNED_INT
		public RuleCall getLengthUNSIGNED_INTTerminalRuleCall_0_1_0() { return cLengthUNSIGNED_INTTerminalRuleCall_0_1_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_0_2() { return cNumberSignKeyword_0_2; }
		
		//value=(S_BYTE_CHAR_STR | D_BYTE_CHAR_STR)
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//(S_BYTE_CHAR_STR | D_BYTE_CHAR_STR)
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }
		
		//S_BYTE_CHAR_STR
		public RuleCall getValueS_BYTE_CHAR_STRTerminalRuleCall_1_0_0() { return cValueS_BYTE_CHAR_STRTerminalRuleCall_1_0_0; }
		
		//D_BYTE_CHAR_STR
		public RuleCall getValueD_BYTE_CHAR_STRTerminalRuleCall_1_0_1() { return cValueD_BYTE_CHAR_STRTerminalRuleCall_1_0_1; }
	}
	public class Time_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Time_Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDurationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTime_Of_DayParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDate_And_TimeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Time_Literal TimeLiteral:
		//	Duration | Time_Of_Day | Date | Date_And_Time;
		@Override public ParserRule getRule() { return rule; }
		
		//Duration | Time_Of_Day | Date | Date_And_Time
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Duration
		public RuleCall getDurationParserRuleCall_0() { return cDurationParserRuleCall_0; }
		
		//Time_Of_Day
		public RuleCall getTime_Of_DayParserRuleCall_1() { return cTime_Of_DayParserRuleCall_1; }
		
		//Date
		public RuleCall getDateParserRuleCall_2() { return cDateParserRuleCall_2; }
		
		//Date_And_Time
		public RuleCall getDate_And_TimeParserRuleCall_3() { return cDate_And_TimeParserRuleCall_3; }
	}
	public class DurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Duration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTime_Type_NameEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cPlusSignKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Assignment cNegativeAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cNegativeHyphenMinusKeyword_2_1_0 = (Keyword)cNegativeAssignment_2_1.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueDuration_ValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword c_Keyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cValueDuration_ValueParserRuleCall_4_1_0 = (RuleCall)cValueAssignment_4_1.eContents().get(0);
		
		//Duration DurationLiteral:
		//	type=Time_Type_Name '#' ('+' | negative?='-')?
		//	value+=Duration_Value ('_' value+=Duration_Value)*;
		@Override public ParserRule getRule() { return rule; }
		
		//type=Time_Type_Name '#' ('+' | negative?='-')? value+=Duration_Value ('_' value+=Duration_Value)*
		public Group getGroup() { return cGroup; }
		
		//type=Time_Type_Name
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//Time_Type_Name
		public RuleCall getTypeTime_Type_NameEnumRuleCall_0_0() { return cTypeTime_Type_NameEnumRuleCall_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }
		
		//('+' | negative?='-')?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'+'
		public Keyword getPlusSignKeyword_2_0() { return cPlusSignKeyword_2_0; }
		
		//negative?='-'
		public Assignment getNegativeAssignment_2_1() { return cNegativeAssignment_2_1; }
		
		//'-'
		public Keyword getNegativeHyphenMinusKeyword_2_1_0() { return cNegativeHyphenMinusKeyword_2_1_0; }
		
		//value+=Duration_Value
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//Duration_Value
		public RuleCall getValueDuration_ValueParserRuleCall_3_0() { return cValueDuration_ValueParserRuleCall_3_0; }
		
		//('_' value+=Duration_Value)*
		public Group getGroup_4() { return cGroup_4; }
		
		//'_'
		public Keyword get_Keyword_4_0() { return c_Keyword_4_0; }
		
		//value+=Duration_Value
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }
		
		//Duration_Value
		public RuleCall getValueDuration_ValueParserRuleCall_4_1_0() { return cValueDuration_ValueParserRuleCall_4_1_0; }
	}
	public class Duration_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Duration_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValueFix_PointParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cUnitAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUnitDuration_UnitEnumRuleCall_1_0 = (RuleCall)cUnitAssignment_1.eContents().get(0);
		
		//Duration_Value DurationValue:
		//	value=Fix_Point
		//	unit=Duration_Unit;
		@Override public ParserRule getRule() { return rule; }
		
		//value=Fix_Point unit=Duration_Unit
		public Group getGroup() { return cGroup; }
		
		//value=Fix_Point
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//Fix_Point
		public RuleCall getValueFix_PointParserRuleCall_0_0() { return cValueFix_PointParserRuleCall_0_0; }
		
		//unit=Duration_Unit
		public Assignment getUnitAssignment_1() { return cUnitAssignment_1; }
		
		//Duration_Unit
		public RuleCall getUnitDuration_UnitEnumRuleCall_1_0() { return cUnitDuration_UnitEnumRuleCall_1_0; }
	}
	public class Fix_PointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Fix_Point");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUNSIGNED_INTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cUNSIGNED_INTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//Fix_Point:
		//	UNSIGNED_INT ('.' UNSIGNED_INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT ('.' UNSIGNED_INT)?
		public Group getGroup() { return cGroup; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall_0() { return cUNSIGNED_INTTerminalRuleCall_0; }
		
		//('.' UNSIGNED_INT)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall_1_1() { return cUNSIGNED_INTTerminalRuleCall_1_1; }
	}
	public class Time_Of_DayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Time_Of_Day");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTod_Type_NameEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueDaytimeParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Time_Of_Day DateLiteral:
		//	type=Tod_Type_Name '#'
		//	value=Daytime;
		@Override public ParserRule getRule() { return rule; }
		
		//type=Tod_Type_Name '#' value=Daytime
		public Group getGroup() { return cGroup; }
		
		//type=Tod_Type_Name
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//Tod_Type_Name
		public RuleCall getTypeTod_Type_NameEnumRuleCall_0_0() { return cTypeTod_Type_NameEnumRuleCall_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }
		
		//value=Daytime
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Daytime
		public RuleCall getValueDaytimeParserRuleCall_2_0() { return cValueDaytimeParserRuleCall_2_0; }
	}
	public class DaytimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Daytime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDay_HourParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDay_MinuteParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cDay_SecondParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Daytime ecore::EDate:
		//	Day_Hour ':' Day_Minute ':' Day_Second;
		@Override public ParserRule getRule() { return rule; }
		
		//Day_Hour ':' Day_Minute ':' Day_Second
		public Group getGroup() { return cGroup; }
		
		//Day_Hour
		public RuleCall getDay_HourParserRuleCall_0() { return cDay_HourParserRuleCall_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//Day_Minute
		public RuleCall getDay_MinuteParserRuleCall_2() { return cDay_MinuteParserRuleCall_2; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//Day_Second
		public RuleCall getDay_SecondParserRuleCall_4() { return cDay_SecondParserRuleCall_4; }
	}
	public class Day_HourElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Day_Hour");
		private final RuleCall cUNSIGNED_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Day_Hour:
		//	UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall() { return cUNSIGNED_INTTerminalRuleCall; }
	}
	public class Day_MinuteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Day_Minute");
		private final RuleCall cUNSIGNED_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Day_Minute:
		//	UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall() { return cUNSIGNED_INTTerminalRuleCall; }
	}
	public class Day_SecondElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Day_Second");
		private final RuleCall cFix_PointParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Day_Second:
		//	Fix_Point;
		@Override public ParserRule getRule() { return rule; }
		
		//Fix_Point
		public RuleCall getFix_PointParserRuleCall() { return cFix_PointParserRuleCall; }
	}
	public class DateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Date");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeDate_Type_NameEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueDate_LiteralParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Date DateLiteral:
		//	type=Date_Type_Name '#'
		//	value=Date_Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//type=Date_Type_Name '#' value=Date_Literal
		public Group getGroup() { return cGroup; }
		
		//type=Date_Type_Name
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//Date_Type_Name
		public RuleCall getTypeDate_Type_NameEnumRuleCall_0_0() { return cTypeDate_Type_NameEnumRuleCall_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }
		
		//value=Date_Literal
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Date_Literal
		public RuleCall getValueDate_LiteralParserRuleCall_2_0() { return cValueDate_LiteralParserRuleCall_2_0; }
	}
	public class Date_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Date_Literal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cYearParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cMonthParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cDayParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Date_Literal ecore::EDate:
		//	Year '-' Month '-' Day;
		@Override public ParserRule getRule() { return rule; }
		
		//Year '-' Month '-' Day
		public Group getGroup() { return cGroup; }
		
		//Year
		public RuleCall getYearParserRuleCall_0() { return cYearParserRuleCall_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//Month
		public RuleCall getMonthParserRuleCall_2() { return cMonthParserRuleCall_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }
		
		//Day
		public RuleCall getDayParserRuleCall_4() { return cDayParserRuleCall_4; }
	}
	public class YearElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Year");
		private final RuleCall cUNSIGNED_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Year:
		//	UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall() { return cUNSIGNED_INTTerminalRuleCall; }
	}
	public class MonthElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Month");
		private final RuleCall cUNSIGNED_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Month:
		//	UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall() { return cUNSIGNED_INTTerminalRuleCall; }
	}
	public class DayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Day");
		private final RuleCall cUNSIGNED_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Day:
		//	UNSIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//UNSIGNED_INT
		public RuleCall getUNSIGNED_INTTerminalRuleCall() { return cUNSIGNED_INTTerminalRuleCall; }
	}
	public class Date_And_TimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Date_And_Time");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeDT_Type_NameEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueDate_And_Time_ValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Date_And_Time DateLiteral:
		//	type=DT_Type_Name '#'
		//	value=Date_And_Time_Value;
		@Override public ParserRule getRule() { return rule; }
		
		//type=DT_Type_Name '#' value=Date_And_Time_Value
		public Group getGroup() { return cGroup; }
		
		//type=DT_Type_Name
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//DT_Type_Name
		public RuleCall getTypeDT_Type_NameEnumRuleCall_0_0() { return cTypeDT_Type_NameEnumRuleCall_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }
		
		//value=Date_And_Time_Value
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Date_And_Time_Value
		public RuleCall getValueDate_And_Time_ValueParserRuleCall_2_0() { return cValueDate_And_Time_ValueParserRuleCall_2_0; }
	}
	public class Date_And_Time_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Date_And_Time_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDate_LiteralParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDaytimeParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Date_And_Time_Value ecore::EDate:
		//	Date_Literal '-' Daytime;
		@Override public ParserRule getRule() { return rule; }
		
		//Date_Literal '-' Daytime
		public Group getGroup() { return cGroup; }
		
		//Date_Literal
		public RuleCall getDate_LiteralParserRuleCall_0() { return cDate_LiteralParserRuleCall_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//Daytime
		public RuleCall getDaytimeParserRuleCall_2() { return cDaytimeParserRuleCall_2; }
	}
	public class Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cDINTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cINTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSINTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLINTKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cUINTKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cUSINTKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cUDINTKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cULINTKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cREALKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLREALKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cSTRINGKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cWSTRINGKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cCHARKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cWCHARKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cTIMEKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cLTIMEKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cTIME_OF_DAYKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cLTIME_OF_DAYKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cTODKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cLTODKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cDATEKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cLDATEKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cDATE_AND_TIMEKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cLDATE_AND_TIMEKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cBOOLKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		
		///************************************************************************
		//								type names
		//********************************************************************** */ Type_Name:
		//	ID
		//	| 'DINT' | 'INT' | 'SINT' | 'LINT' //Sign_Int_Type_Name
		//	| 'UINT' | 'USINT' | 'UDINT' | 'ULINT' //Unsign_Int_Type_Name
		//	| 'REAL' | 'LREAL'
		//	| 'STRING' | 'WSTRING' | 'CHAR' | 'WCHAR'
		//	| 'TIME' | 'LTIME'
		//	| 'TIME_OF_DAY' | 'LTIME_OF_DAY' | 'TOD' | 'LTOD' // also allow 'LTIME_OF_DAY'
		//	| 'DATE' | 'LDATE'
		//	| 'DATE_AND_TIME' | 'LDATE_AND_TIME'
		//	| 'BOOL';
		@Override public ParserRule getRule() { return rule; }
		
		//ID | 'DINT' | 'INT' | 'SINT' | 'LINT' //Sign_Int_Type_Name
		//| 'UINT' | 'USINT' | 'UDINT' | 'ULINT' //Unsign_Int_Type_Name
		//| 'REAL' | 'LREAL' | 'STRING' | 'WSTRING' | 'CHAR' | 'WCHAR' | 'TIME' | 'LTIME' | 'TIME_OF_DAY' | 'LTIME_OF_DAY' | 'TOD'
		//| 'LTOD' // also allow 'LTIME_OF_DAY'
		//| 'DATE' | 'LDATE' | 'DATE_AND_TIME' | 'LDATE_AND_TIME' | 'BOOL'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//'DINT'
		public Keyword getDINTKeyword_1() { return cDINTKeyword_1; }
		
		//'INT'
		public Keyword getINTKeyword_2() { return cINTKeyword_2; }
		
		//'SINT'
		public Keyword getSINTKeyword_3() { return cSINTKeyword_3; }
		
		//'LINT'
		public Keyword getLINTKeyword_4() { return cLINTKeyword_4; }
		
		//'UINT'
		public Keyword getUINTKeyword_5() { return cUINTKeyword_5; }
		
		//'USINT'
		public Keyword getUSINTKeyword_6() { return cUSINTKeyword_6; }
		
		//'UDINT'
		public Keyword getUDINTKeyword_7() { return cUDINTKeyword_7; }
		
		//'ULINT'
		public Keyword getULINTKeyword_8() { return cULINTKeyword_8; }
		
		//'REAL'
		public Keyword getREALKeyword_9() { return cREALKeyword_9; }
		
		//'LREAL'
		public Keyword getLREALKeyword_10() { return cLREALKeyword_10; }
		
		//'STRING'
		public Keyword getSTRINGKeyword_11() { return cSTRINGKeyword_11; }
		
		//'WSTRING'
		public Keyword getWSTRINGKeyword_12() { return cWSTRINGKeyword_12; }
		
		//'CHAR'
		public Keyword getCHARKeyword_13() { return cCHARKeyword_13; }
		
		//'WCHAR'
		public Keyword getWCHARKeyword_14() { return cWCHARKeyword_14; }
		
		//'TIME'
		public Keyword getTIMEKeyword_15() { return cTIMEKeyword_15; }
		
		//'LTIME'
		public Keyword getLTIMEKeyword_16() { return cLTIMEKeyword_16; }
		
		//'TIME_OF_DAY'
		public Keyword getTIME_OF_DAYKeyword_17() { return cTIME_OF_DAYKeyword_17; }
		
		//'LTIME_OF_DAY'
		public Keyword getLTIME_OF_DAYKeyword_18() { return cLTIME_OF_DAYKeyword_18; }
		
		//'TOD'
		public Keyword getTODKeyword_19() { return cTODKeyword_19; }
		
		//'LTOD'
		public Keyword getLTODKeyword_20() { return cLTODKeyword_20; }
		
		//'DATE'
		public Keyword getDATEKeyword_21() { return cDATEKeyword_21; }
		
		//'LDATE'
		public Keyword getLDATEKeyword_22() { return cLDATEKeyword_22; }
		
		//'DATE_AND_TIME'
		public Keyword getDATE_AND_TIMEKeyword_23() { return cDATE_AND_TIMEKeyword_23; }
		
		//'LDATE_AND_TIME'
		public Keyword getLDATE_AND_TIMEKeyword_24() { return cLDATE_AND_TIMEKeyword_24; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_25() { return cBOOLKeyword_25; }
	}
	
	public class Or_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Or_Operator");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORORKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum Or_Operator returns BinaryOperator:
		//	OR;
		@Override
		public EnumRule getRule() { return rule; }
		
		//OR
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }
		
		//"OR"
		public Keyword getORORKeyword_0() { return cORORKeyword_0; }
	}
	public class Xor_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Xor_Operator");
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cXORXORKeyword_0 = (Keyword)cXOREnumLiteralDeclaration.eContents().get(0);
		
		//enum Xor_Operator returns BinaryOperator:
		//	XOR;
		@Override
		public EnumRule getRule() { return rule; }
		
		//XOR
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration() { return cXOREnumLiteralDeclaration; }
		
		//"XOR"
		public Keyword getXORXORKeyword_0() { return cXORXORKeyword_0; }
	}
	public class And_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.And_Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDANDKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cANDAmpersandKeyword_1_0 = (Keyword)cANDEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum And_Operator returns BinaryOperator:
		//	AND | AND='&';
		@Override
		public EnumRule getRule() { return rule; }
		
		//AND | AND='&'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AND
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }
		
		//"AND"
		public Keyword getANDANDKeyword_0_0() { return cANDANDKeyword_0_0; }
		
		//AND='&'
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_1() { return cANDEnumLiteralDeclaration_1; }
		
		//'&'
		public Keyword getANDAmpersandKeyword_1_0() { return cANDAmpersandKeyword_1_0; }
	}
	public class Compare_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Compare_Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNELessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cNEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Compare_Operator returns BinaryOperator:
		//	EQ='=' | NE='<>';
		@Override
		public EnumRule getRule() { return rule; }
		
		//EQ='=' | NE='<>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQ='='
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }
		
		//NE='<>'
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_1() { return cNEEnumLiteralDeclaration_1; }
		
		//'<>'
		public Keyword getNELessThanSignGreaterThanSignKeyword_1_0() { return cNELessThanSignGreaterThanSignKeyword_1_0; }
	}
	public class Equ_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Equ_Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLTLessThanSignKeyword_0_0 = (Keyword)cLTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLELessThanSignEqualsSignKeyword_1_0 = (Keyword)cLEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGTGreaterThanSignKeyword_2_0 = (Keyword)cGTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_3_0 = (Keyword)cGEEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Equ_Operator returns BinaryOperator:
		//	LT='<' | LE='<=' | GT='>' | GE='>=';
		@Override
		public EnumRule getRule() { return rule; }
		
		//LT='<' | LE='<=' | GT='>' | GE='>='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LT='<'
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_0() { return cLTEnumLiteralDeclaration_0; }
		
		//'<'
		public Keyword getLTLessThanSignKeyword_0_0() { return cLTLessThanSignKeyword_0_0; }
		
		//LE='<='
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_1() { return cLEEnumLiteralDeclaration_1; }
		
		//'<='
		public Keyword getLELessThanSignEqualsSignKeyword_1_0() { return cLELessThanSignEqualsSignKeyword_1_0; }
		
		//GT='>'
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_2() { return cGTEnumLiteralDeclaration_2; }
		
		//'>'
		public Keyword getGTGreaterThanSignKeyword_2_0() { return cGTGreaterThanSignKeyword_2_0; }
		
		//GE='>='
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_3() { return cGEEnumLiteralDeclaration_3; }
		
		//'>='
		public Keyword getGEGreaterThanSignEqualsSignKeyword_3_0() { return cGEGreaterThanSignEqualsSignKeyword_3_0; }
	}
	public class Add_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Add_Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDPlusSignKeyword_0_0 = (Keyword)cADDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBHyphenMinusKeyword_1_0 = (Keyword)cSUBEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Add_Operator returns BinaryOperator:
		//	ADD='+' | SUB='-';
		@Override
		public EnumRule getRule() { return rule; }
		
		//ADD='+' | SUB='-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ADD='+'
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_0() { return cADDEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getADDPlusSignKeyword_0_0() { return cADDPlusSignKeyword_0_0; }
		
		//SUB='-'
		public EnumLiteralDeclaration getSUBEnumLiteralDeclaration_1() { return cSUBEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getSUBHyphenMinusKeyword_1_0() { return cSUBHyphenMinusKeyword_1_0; }
	}
	public class Term_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Term_Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULAsteriskKeyword_0_0 = (Keyword)cMULEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODMODKeyword_2_0 = (Keyword)cMODEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Term_Operator returns BinaryOperator:
		//	MUL='*' | DIV='/' | MOD;
		@Override
		public EnumRule getRule() { return rule; }
		
		//MUL='*' | DIV='/' | MOD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MUL='*'
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_0() { return cMULEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getMULAsteriskKeyword_0_0() { return cMULAsteriskKeyword_0_0; }
		
		//DIV='/'
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
		
		//MOD
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_2() { return cMODEnumLiteralDeclaration_2; }
		
		//"MOD"
		public Keyword getMODMODKeyword_2_0() { return cMODMODKeyword_2_0; }
	}
	public class Power_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Power_Operator");
		private final EnumLiteralDeclaration cPOWEREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPOWERAsteriskAsteriskKeyword_0 = (Keyword)cPOWEREnumLiteralDeclaration.eContents().get(0);
		
		//enum Power_Operator returns BinaryOperator:
		//	POWER='**';
		@Override
		public EnumRule getRule() { return rule; }
		
		//POWER='**'
		public EnumLiteralDeclaration getPOWEREnumLiteralDeclaration() { return cPOWEREnumLiteralDeclaration; }
		
		//'**'
		public Keyword getPOWERAsteriskAsteriskKeyword_0() { return cPOWERAsteriskAsteriskKeyword_0; }
	}
	public class Unary_OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Unary_Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINUSHyphenMinusKeyword_0_0 = (Keyword)cMINUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUSPlusSignKeyword_1_0 = (Keyword)cPLUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNOTNOTKeyword_2_0 = (Keyword)cNOTEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Unary_Operator returns UnaryOperator:
		//	MINUS='-' | PLUS='+' | NOT;
		@Override
		public EnumRule getRule() { return rule; }
		
		//MINUS='-' | PLUS='+' | NOT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_0() { return cMINUSEnumLiteralDeclaration_0; }
		
		//'-'
		public Keyword getMINUSHyphenMinusKeyword_0_0() { return cMINUSHyphenMinusKeyword_0_0; }
		
		//PLUS='+'
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_1() { return cPLUSEnumLiteralDeclaration_1; }
		
		//'+'
		public Keyword getPLUSPlusSignKeyword_1_0() { return cPLUSPlusSignKeyword_1_0; }
		
		//NOT
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_2() { return cNOTEnumLiteralDeclaration_2; }
		
		//"NOT"
		public Keyword getNOTNOTKeyword_2_0() { return cNOTNOTKeyword_2_0; }
	}
	public class Duration_UnitElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Duration_Unit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDAYSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDAYSDKeyword_0_0 = (Keyword)cDAYSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cHOURSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cHOURSHKeyword_1_0 = (Keyword)cHOURSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMINUTESEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMINUTESMKeyword_2_0 = (Keyword)cMINUTESEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSECONDSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSECONDSSKeyword_3_0 = (Keyword)cSECONDSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMILLISEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMILLISMsKeyword_4_0 = (Keyword)cMILLISEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cMICROSEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cMICROSUsKeyword_5_0 = (Keyword)cMICROSEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cNANOSEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cNANOSNsKeyword_6_0 = (Keyword)cNANOSEnumLiteralDeclaration_6.eContents().get(0);
		
		//enum Duration_Unit:
		//	DAYS='d' | HOURS='h' | MINUTES='m' | SECONDS='s' | MILLIS='ms' | MICROS='us' | NANOS='ns';
		@Override
		public EnumRule getRule() { return rule; }
		
		//DAYS='d' | HOURS='h' | MINUTES='m' | SECONDS='s' | MILLIS='ms' | MICROS='us' | NANOS='ns'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DAYS='d'
		public EnumLiteralDeclaration getDAYSEnumLiteralDeclaration_0() { return cDAYSEnumLiteralDeclaration_0; }
		
		//'d'
		public Keyword getDAYSDKeyword_0_0() { return cDAYSDKeyword_0_0; }
		
		//HOURS='h'
		public EnumLiteralDeclaration getHOURSEnumLiteralDeclaration_1() { return cHOURSEnumLiteralDeclaration_1; }
		
		//'h'
		public Keyword getHOURSHKeyword_1_0() { return cHOURSHKeyword_1_0; }
		
		//MINUTES='m'
		public EnumLiteralDeclaration getMINUTESEnumLiteralDeclaration_2() { return cMINUTESEnumLiteralDeclaration_2; }
		
		//'m'
		public Keyword getMINUTESMKeyword_2_0() { return cMINUTESMKeyword_2_0; }
		
		//SECONDS='s'
		public EnumLiteralDeclaration getSECONDSEnumLiteralDeclaration_3() { return cSECONDSEnumLiteralDeclaration_3; }
		
		//'s'
		public Keyword getSECONDSSKeyword_3_0() { return cSECONDSSKeyword_3_0; }
		
		//MILLIS='ms'
		public EnumLiteralDeclaration getMILLISEnumLiteralDeclaration_4() { return cMILLISEnumLiteralDeclaration_4; }
		
		//'ms'
		public Keyword getMILLISMsKeyword_4_0() { return cMILLISMsKeyword_4_0; }
		
		//MICROS='us'
		public EnumLiteralDeclaration getMICROSEnumLiteralDeclaration_5() { return cMICROSEnumLiteralDeclaration_5; }
		
		//'us'
		public Keyword getMICROSUsKeyword_5_0() { return cMICROSUsKeyword_5_0; }
		
		//NANOS='ns'
		public EnumLiteralDeclaration getNANOSEnumLiteralDeclaration_6() { return cNANOSEnumLiteralDeclaration_6; }
		
		//'ns'
		public Keyword getNANOSNsKeyword_6_0() { return cNANOSNsKeyword_6_0; }
	}
	public class Int_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Int_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDINTDINTKeyword_0_0 = (Keyword)cDINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cINTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cINTINTKeyword_1_0 = (Keyword)cINTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSINTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSINTSINTKeyword_2_0 = (Keyword)cSINTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLINTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLINTLINTKeyword_3_0 = (Keyword)cLINTEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cUINTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cUINTUINTKeyword_4_0 = (Keyword)cUINTEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cUSINTEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cUSINTUSINTKeyword_5_0 = (Keyword)cUSINTEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cUDINTEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cUDINTUDINTKeyword_6_0 = (Keyword)cUDINTEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cULINTEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cULINTULINTKeyword_7_0 = (Keyword)cULINTEnumLiteralDeclaration_7.eContents().get(0);
		
		//enum Int_Type_Name returns Type:
		//	DINT | INT | SINT | LINT //Sign_Int_Type_Name
		//	| UINT | USINT | UDINT | ULINT //Unsign_Int_Type_Name
		//;
		@Override
		public EnumRule getRule() { return rule; }
		
		//DINT | INT | SINT | LINT //Sign_Int_Type_Name
		//| UINT | USINT | UDINT | ULINT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DINT
		public EnumLiteralDeclaration getDINTEnumLiteralDeclaration_0() { return cDINTEnumLiteralDeclaration_0; }
		
		//"DINT"
		public Keyword getDINTDINTKeyword_0_0() { return cDINTDINTKeyword_0_0; }
		
		//INT
		public EnumLiteralDeclaration getINTEnumLiteralDeclaration_1() { return cINTEnumLiteralDeclaration_1; }
		
		//"INT"
		public Keyword getINTINTKeyword_1_0() { return cINTINTKeyword_1_0; }
		
		//SINT
		public EnumLiteralDeclaration getSINTEnumLiteralDeclaration_2() { return cSINTEnumLiteralDeclaration_2; }
		
		//"SINT"
		public Keyword getSINTSINTKeyword_2_0() { return cSINTSINTKeyword_2_0; }
		
		//LINT
		public EnumLiteralDeclaration getLINTEnumLiteralDeclaration_3() { return cLINTEnumLiteralDeclaration_3; }
		
		//"LINT"
		public Keyword getLINTLINTKeyword_3_0() { return cLINTLINTKeyword_3_0; }
		
		//UINT
		public EnumLiteralDeclaration getUINTEnumLiteralDeclaration_4() { return cUINTEnumLiteralDeclaration_4; }
		
		//"UINT"
		public Keyword getUINTUINTKeyword_4_0() { return cUINTUINTKeyword_4_0; }
		
		//USINT
		public EnumLiteralDeclaration getUSINTEnumLiteralDeclaration_5() { return cUSINTEnumLiteralDeclaration_5; }
		
		//"USINT"
		public Keyword getUSINTUSINTKeyword_5_0() { return cUSINTUSINTKeyword_5_0; }
		
		//UDINT
		public EnumLiteralDeclaration getUDINTEnumLiteralDeclaration_6() { return cUDINTEnumLiteralDeclaration_6; }
		
		//"UDINT"
		public Keyword getUDINTUDINTKeyword_6_0() { return cUDINTUDINTKeyword_6_0; }
		
		//ULINT
		public EnumLiteralDeclaration getULINTEnumLiteralDeclaration_7() { return cULINTEnumLiteralDeclaration_7; }
		
		//"ULINT"
		public Keyword getULINTULINTKeyword_7_0() { return cULINTULINTKeyword_7_0; }
	}
	public class Real_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Real_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cREALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cREALREALKeyword_0_0 = (Keyword)cREALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLREALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLREALLREALKeyword_1_0 = (Keyword)cLREALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Real_Type_Name returns Type:
		//	REAL | LREAL;
		@Override
		public EnumRule getRule() { return rule; }
		
		//REAL | LREAL
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//REAL
		public EnumLiteralDeclaration getREALEnumLiteralDeclaration_0() { return cREALEnumLiteralDeclaration_0; }
		
		//"REAL"
		public Keyword getREALREALKeyword_0_0() { return cREALREALKeyword_0_0; }
		
		//LREAL
		public EnumLiteralDeclaration getLREALEnumLiteralDeclaration_1() { return cLREALEnumLiteralDeclaration_1; }
		
		//"LREAL"
		public Keyword getLREALLREALKeyword_1_0() { return cLREALLREALKeyword_1_0; }
	}
	public class String_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.String_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSTRINGEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSTRINGSTRINGKeyword_0_0 = (Keyword)cSTRINGEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cWSTRINGEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cWSTRINGWSTRINGKeyword_1_0 = (Keyword)cWSTRINGEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCHAREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCHARCHARKeyword_2_0 = (Keyword)cCHAREnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cWCHAREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cWCHARWCHARKeyword_3_0 = (Keyword)cWCHAREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum String_Type_Name returns Type:
		//	STRING | WSTRING | CHAR | WCHAR;
		@Override
		public EnumRule getRule() { return rule; }
		
		//STRING | WSTRING | CHAR | WCHAR
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public EnumLiteralDeclaration getSTRINGEnumLiteralDeclaration_0() { return cSTRINGEnumLiteralDeclaration_0; }
		
		//"STRING"
		public Keyword getSTRINGSTRINGKeyword_0_0() { return cSTRINGSTRINGKeyword_0_0; }
		
		//WSTRING
		public EnumLiteralDeclaration getWSTRINGEnumLiteralDeclaration_1() { return cWSTRINGEnumLiteralDeclaration_1; }
		
		//"WSTRING"
		public Keyword getWSTRINGWSTRINGKeyword_1_0() { return cWSTRINGWSTRINGKeyword_1_0; }
		
		//CHAR
		public EnumLiteralDeclaration getCHAREnumLiteralDeclaration_2() { return cCHAREnumLiteralDeclaration_2; }
		
		//"CHAR"
		public Keyword getCHARCHARKeyword_2_0() { return cCHARCHARKeyword_2_0; }
		
		//WCHAR
		public EnumLiteralDeclaration getWCHAREnumLiteralDeclaration_3() { return cWCHAREnumLiteralDeclaration_3; }
		
		//"WCHAR"
		public Keyword getWCHARWCHARKeyword_3_0() { return cWCHARWCHARKeyword_3_0; }
	}
	public class Time_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Time_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIMEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIMETIMEKeyword_0_0 = (Keyword)cTIMEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLTIMEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLTIMELTIMEKeyword_1_0 = (Keyword)cLTIMEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTTKeyword_2_0 = (Keyword)cTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLTLTKeyword_3_0 = (Keyword)cLTEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Time_Type_Name returns Type:
		//	TIME | LTIME | T | LT // also allow short type names
		//;
		@Override
		public EnumRule getRule() { return rule; }
		
		//TIME | LTIME | T | LT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TIME
		public EnumLiteralDeclaration getTIMEEnumLiteralDeclaration_0() { return cTIMEEnumLiteralDeclaration_0; }
		
		//"TIME"
		public Keyword getTIMETIMEKeyword_0_0() { return cTIMETIMEKeyword_0_0; }
		
		//LTIME
		public EnumLiteralDeclaration getLTIMEEnumLiteralDeclaration_1() { return cLTIMEEnumLiteralDeclaration_1; }
		
		//"LTIME"
		public Keyword getLTIMELTIMEKeyword_1_0() { return cLTIMELTIMEKeyword_1_0; }
		
		//T
		public EnumLiteralDeclaration getTEnumLiteralDeclaration_2() { return cTEnumLiteralDeclaration_2; }
		
		//"T"
		public Keyword getTTKeyword_2_0() { return cTTKeyword_2_0; }
		
		//LT
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_3() { return cLTEnumLiteralDeclaration_3; }
		
		//"LT"
		public Keyword getLTLTKeyword_3_0() { return cLTLTKeyword_3_0; }
	}
	public class Tod_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Tod_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIME_OF_DAYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIME_OF_DAYTIME_OF_DAYKeyword_0_0 = (Keyword)cTIME_OF_DAYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLTIME_OF_DAYEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLTIME_OF_DAYLTIME_OF_DAYKeyword_1_0 = (Keyword)cLTIME_OF_DAYEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTODEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTODTODKeyword_2_0 = (Keyword)cTODEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLTODEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLTODLTODKeyword_3_0 = (Keyword)cLTODEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Tod_Type_Name returns Type:
		//	TIME_OF_DAY | LTIME_OF_DAY | TOD | LTOD // also allow 'LTIME_OF_DAY'
		//;
		@Override
		public EnumRule getRule() { return rule; }
		
		//TIME_OF_DAY | LTIME_OF_DAY | TOD | LTOD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TIME_OF_DAY
		public EnumLiteralDeclaration getTIME_OF_DAYEnumLiteralDeclaration_0() { return cTIME_OF_DAYEnumLiteralDeclaration_0; }
		
		//"TIME_OF_DAY"
		public Keyword getTIME_OF_DAYTIME_OF_DAYKeyword_0_0() { return cTIME_OF_DAYTIME_OF_DAYKeyword_0_0; }
		
		//LTIME_OF_DAY
		public EnumLiteralDeclaration getLTIME_OF_DAYEnumLiteralDeclaration_1() { return cLTIME_OF_DAYEnumLiteralDeclaration_1; }
		
		//"LTIME_OF_DAY"
		public Keyword getLTIME_OF_DAYLTIME_OF_DAYKeyword_1_0() { return cLTIME_OF_DAYLTIME_OF_DAYKeyword_1_0; }
		
		//TOD
		public EnumLiteralDeclaration getTODEnumLiteralDeclaration_2() { return cTODEnumLiteralDeclaration_2; }
		
		//"TOD"
		public Keyword getTODTODKeyword_2_0() { return cTODTODKeyword_2_0; }
		
		//LTOD
		public EnumLiteralDeclaration getLTODEnumLiteralDeclaration_3() { return cLTODEnumLiteralDeclaration_3; }
		
		//"LTOD"
		public Keyword getLTODLTODKeyword_3_0() { return cLTODLTODKeyword_3_0; }
	}
	public class Date_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Date_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDATEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDATEDATEKeyword_0_0 = (Keyword)cDATEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLDATEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLDATELDATEKeyword_1_0 = (Keyword)cLDATEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDDKeyword_2_0 = (Keyword)cDEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLDEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLDLDKeyword_3_0 = (Keyword)cLDEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Date_Type_Name returns Type:
		//	DATE | LDATE | D | LD // also allow short type names
		//;
		@Override
		public EnumRule getRule() { return rule; }
		
		//DATE | LDATE | D | LD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DATE
		public EnumLiteralDeclaration getDATEEnumLiteralDeclaration_0() { return cDATEEnumLiteralDeclaration_0; }
		
		//"DATE"
		public Keyword getDATEDATEKeyword_0_0() { return cDATEDATEKeyword_0_0; }
		
		//LDATE
		public EnumLiteralDeclaration getLDATEEnumLiteralDeclaration_1() { return cLDATEEnumLiteralDeclaration_1; }
		
		//"LDATE"
		public Keyword getLDATELDATEKeyword_1_0() { return cLDATELDATEKeyword_1_0; }
		
		//D
		public EnumLiteralDeclaration getDEnumLiteralDeclaration_2() { return cDEnumLiteralDeclaration_2; }
		
		//"D"
		public Keyword getDDKeyword_2_0() { return cDDKeyword_2_0; }
		
		//LD
		public EnumLiteralDeclaration getLDEnumLiteralDeclaration_3() { return cLDEnumLiteralDeclaration_3; }
		
		//"LD"
		public Keyword getLDLDKeyword_3_0() { return cLDLDKeyword_3_0; }
	}
	public class DT_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.DT_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDATE_AND_TIMEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDATE_AND_TIMEDATE_AND_TIMEKeyword_0_0 = (Keyword)cDATE_AND_TIMEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLDATE_AND_TIMEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLDATE_AND_TIMELDATE_AND_TIMEKeyword_1_0 = (Keyword)cLDATE_AND_TIMEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDTDTKeyword_2_0 = (Keyword)cDTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLDTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLDTLDTKeyword_3_0 = (Keyword)cLDTEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum DT_Type_Name returns Type:
		//	DATE_AND_TIME | LDATE_AND_TIME | DT | LDT // also allow 'LDATE_AND_TIME'
		//;
		@Override
		public EnumRule getRule() { return rule; }
		
		//DATE_AND_TIME | LDATE_AND_TIME | DT | LDT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DATE_AND_TIME
		public EnumLiteralDeclaration getDATE_AND_TIMEEnumLiteralDeclaration_0() { return cDATE_AND_TIMEEnumLiteralDeclaration_0; }
		
		//"DATE_AND_TIME"
		public Keyword getDATE_AND_TIMEDATE_AND_TIMEKeyword_0_0() { return cDATE_AND_TIMEDATE_AND_TIMEKeyword_0_0; }
		
		//LDATE_AND_TIME
		public EnumLiteralDeclaration getLDATE_AND_TIMEEnumLiteralDeclaration_1() { return cLDATE_AND_TIMEEnumLiteralDeclaration_1; }
		
		//"LDATE_AND_TIME"
		public Keyword getLDATE_AND_TIMELDATE_AND_TIMEKeyword_1_0() { return cLDATE_AND_TIMELDATE_AND_TIMEKeyword_1_0; }
		
		//DT
		public EnumLiteralDeclaration getDTEnumLiteralDeclaration_2() { return cDTEnumLiteralDeclaration_2; }
		
		//"DT"
		public Keyword getDTDTKeyword_2_0() { return cDTDTKeyword_2_0; }
		
		//LDT
		public EnumLiteralDeclaration getLDTEnumLiteralDeclaration_3() { return cLDTEnumLiteralDeclaration_3; }
		
		//"LDT"
		public Keyword getLDTLDTKeyword_3_0() { return cLDTLDTKeyword_3_0; }
	}
	public class Bool_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Bool_Type_Name");
		private final EnumLiteralDeclaration cBOOLEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cBOOLBOOLKeyword_0 = (Keyword)cBOOLEnumLiteralDeclaration.eContents().get(0);
		
		//enum Bool_Type_Name returns Type:
		//	BOOL;
		@Override
		public EnumRule getRule() { return rule; }
		
		//BOOL
		public EnumLiteralDeclaration getBOOLEnumLiteralDeclaration() { return cBOOLEnumLiteralDeclaration; }
		
		//"BOOL"
		public Keyword getBOOLBOOLKeyword_0() { return cBOOLBOOLKeyword_0; }
	}
	public class Any_Bit_Type_NameElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.Any_Bit_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBYTEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBYTEBYTEKeyword_0_0 = (Keyword)cBYTEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cWORDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cWORDWORDKeyword_1_0 = (Keyword)cWORDEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDWORDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDWORDDWORDKeyword_2_0 = (Keyword)cDWORDEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLWORDEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLWORDLWORDKeyword_3_0 = (Keyword)cLWORDEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Any_Bit_Type_Name returns Type:
		//	BYTE | WORD | DWORD | LWORD;
		@Override
		public EnumRule getRule() { return rule; }
		
		//BYTE | WORD | DWORD | LWORD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BYTE
		public EnumLiteralDeclaration getBYTEEnumLiteralDeclaration_0() { return cBYTEEnumLiteralDeclaration_0; }
		
		//"BYTE"
		public Keyword getBYTEBYTEKeyword_0_0() { return cBYTEBYTEKeyword_0_0; }
		
		//WORD
		public EnumLiteralDeclaration getWORDEnumLiteralDeclaration_1() { return cWORDEnumLiteralDeclaration_1; }
		
		//"WORD"
		public Keyword getWORDWORDKeyword_1_0() { return cWORDWORDKeyword_1_0; }
		
		//DWORD
		public EnumLiteralDeclaration getDWORDEnumLiteralDeclaration_2() { return cDWORDEnumLiteralDeclaration_2; }
		
		//"DWORD"
		public Keyword getDWORDDWORDKeyword_2_0() { return cDWORDDWORDKeyword_2_0; }
		
		//LWORD
		public EnumLiteralDeclaration getLWORDEnumLiteralDeclaration_3() { return cLWORDEnumLiteralDeclaration_3; }
		
		//"LWORD"
		public Keyword getLWORDLWORDKeyword_3_0() { return cLWORDLWORDKeyword_3_0; }
	}
	
	private final StructuredTextAlgorithmElements pStructuredTextAlgorithm;
	private final Var_Decl_InitElements pVar_Decl_Init;
	private final Stmt_ListElements pStmt_List;
	private final StmtElements pStmt;
	private final Assign_StmtElements pAssign_Stmt;
	private final Subprog_Ctrl_StmtElements pSubprog_Ctrl_Stmt;
	private final Selection_StmtElements pSelection_Stmt;
	private final IF_StmtElements pIF_Stmt;
	private final ELSIF_ClauseElements pELSIF_Clause;
	private final ELSE_ClauseElements pELSE_Clause;
	private final Case_StmtElements pCase_Stmt;
	private final Case_SelectionElements pCase_Selection;
	private final Iteration_StmtElements pIteration_Stmt;
	private final For_StmtElements pFor_Stmt;
	private final While_StmtElements pWhile_Stmt;
	private final Repeat_StmtElements pRepeat_Stmt;
	private final ExpressionElements pExpression;
	private final Or_OperatorElements eOr_Operator;
	private final Or_ExpressionElements pOr_Expression;
	private final Xor_OperatorElements eXor_Operator;
	private final Xor_ExprElements pXor_Expr;
	private final And_OperatorElements eAnd_Operator;
	private final And_ExprElements pAnd_Expr;
	private final Compare_OperatorElements eCompare_Operator;
	private final Compare_ExprElements pCompare_Expr;
	private final Equ_OperatorElements eEqu_Operator;
	private final Equ_ExprElements pEqu_Expr;
	private final Add_OperatorElements eAdd_Operator;
	private final Add_ExprElements pAdd_Expr;
	private final Term_OperatorElements eTerm_Operator;
	private final TermElements pTerm;
	private final Power_OperatorElements ePower_Operator;
	private final Power_ExprElements pPower_Expr;
	private final Unary_OperatorElements eUnary_Operator;
	private final Unary_ExprElements pUnary_Expr;
	private final Primary_ExprElements pPrimary_Expr;
	private final Func_CallElements pFunc_Call;
	private final Param_AssignElements pParam_Assign;
	private final Param_Assign_InElements pParam_Assign_In;
	private final Param_Assign_OutElements pParam_Assign_Out;
	private final VariableElements pVariable;
	private final Variable_SubscriptElements pVariable_Subscript;
	private final Variable_AdapterElements pVariable_Adapter;
	private final Adapter_NameElements pAdapter_Name;
	private final Variable_PrimaryElements pVariable_Primary;
	private final Variable_NameElements pVariable_Name;
	private final ConstantElements pConstant;
	private final Numeric_LiteralElements pNumeric_Literal;
	private final Int_LiteralElements pInt_Literal;
	private final Signed_IntElements pSigned_Int;
	private final Array_SizeElements pArray_Size;
	private final Real_LiteralElements pReal_Literal;
	private final Real_ValueElements pReal_Value;
	private final Bool_LiteralElements pBool_Literal;
	private final Bool_ValueElements pBool_Value;
	private final Char_LiteralElements pChar_Literal;
	private final Time_LiteralElements pTime_Literal;
	private final DurationElements pDuration;
	private final Duration_ValueElements pDuration_Value;
	private final Duration_UnitElements eDuration_Unit;
	private final Fix_PointElements pFix_Point;
	private final Time_Of_DayElements pTime_Of_Day;
	private final DaytimeElements pDaytime;
	private final Day_HourElements pDay_Hour;
	private final Day_MinuteElements pDay_Minute;
	private final Day_SecondElements pDay_Second;
	private final DateElements pDate;
	private final Date_LiteralElements pDate_Literal;
	private final YearElements pYear;
	private final MonthElements pMonth;
	private final DayElements pDay;
	private final Date_And_TimeElements pDate_And_Time;
	private final Date_And_Time_ValueElements pDate_And_Time_Value;
	private final Type_NameElements pType_Name;
	private final Int_Type_NameElements eInt_Type_Name;
	private final Real_Type_NameElements eReal_Type_Name;
	private final String_Type_NameElements eString_Type_Name;
	private final Time_Type_NameElements eTime_Type_Name;
	private final Tod_Type_NameElements eTod_Type_Name;
	private final Date_Type_NameElements eDate_Type_Name;
	private final DT_Type_NameElements eDT_Type_Name;
	private final Bool_Type_NameElements eBool_Type_Name;
	private final Any_Bit_Type_NameElements eAny_Bit_Type_Name;
	private final TerminalRule tLETTER;
	private final TerminalRule tDIGIT;
	private final TerminalRule tBIT;
	private final TerminalRule tOCTAL_DIGIT;
	private final TerminalRule tHEX_DIGIT;
	private final TerminalRule tID;
	private final TerminalRule tBINARY_INT;
	private final TerminalRule tOCTAL_INT;
	private final TerminalRule tHEX_INT;
	private final TerminalRule tUNSIGNED_INT;
	private final TerminalRule tS_BYTE_CHAR_STR;
	private final TerminalRule tD_BYTE_CHAR_STR;
	private final TerminalRule tS_BYTE_CHAR_VALUE;
	private final TerminalRule tD_BYTE_CHAR_VALUE;
	private final TerminalRule tCOMMON_CHAR_VALUE;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public StructuredTextGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pStructuredTextAlgorithm = new StructuredTextAlgorithmElements();
		this.pVar_Decl_Init = new Var_Decl_InitElements();
		this.pStmt_List = new Stmt_ListElements();
		this.pStmt = new StmtElements();
		this.pAssign_Stmt = new Assign_StmtElements();
		this.pSubprog_Ctrl_Stmt = new Subprog_Ctrl_StmtElements();
		this.pSelection_Stmt = new Selection_StmtElements();
		this.pIF_Stmt = new IF_StmtElements();
		this.pELSIF_Clause = new ELSIF_ClauseElements();
		this.pELSE_Clause = new ELSE_ClauseElements();
		this.pCase_Stmt = new Case_StmtElements();
		this.pCase_Selection = new Case_SelectionElements();
		this.pIteration_Stmt = new Iteration_StmtElements();
		this.pFor_Stmt = new For_StmtElements();
		this.pWhile_Stmt = new While_StmtElements();
		this.pRepeat_Stmt = new Repeat_StmtElements();
		this.pExpression = new ExpressionElements();
		this.eOr_Operator = new Or_OperatorElements();
		this.pOr_Expression = new Or_ExpressionElements();
		this.eXor_Operator = new Xor_OperatorElements();
		this.pXor_Expr = new Xor_ExprElements();
		this.eAnd_Operator = new And_OperatorElements();
		this.pAnd_Expr = new And_ExprElements();
		this.eCompare_Operator = new Compare_OperatorElements();
		this.pCompare_Expr = new Compare_ExprElements();
		this.eEqu_Operator = new Equ_OperatorElements();
		this.pEqu_Expr = new Equ_ExprElements();
		this.eAdd_Operator = new Add_OperatorElements();
		this.pAdd_Expr = new Add_ExprElements();
		this.eTerm_Operator = new Term_OperatorElements();
		this.pTerm = new TermElements();
		this.ePower_Operator = new Power_OperatorElements();
		this.pPower_Expr = new Power_ExprElements();
		this.eUnary_Operator = new Unary_OperatorElements();
		this.pUnary_Expr = new Unary_ExprElements();
		this.pPrimary_Expr = new Primary_ExprElements();
		this.pFunc_Call = new Func_CallElements();
		this.pParam_Assign = new Param_AssignElements();
		this.pParam_Assign_In = new Param_Assign_InElements();
		this.pParam_Assign_Out = new Param_Assign_OutElements();
		this.pVariable = new VariableElements();
		this.pVariable_Subscript = new Variable_SubscriptElements();
		this.pVariable_Adapter = new Variable_AdapterElements();
		this.pAdapter_Name = new Adapter_NameElements();
		this.pVariable_Primary = new Variable_PrimaryElements();
		this.pVariable_Name = new Variable_NameElements();
		this.pConstant = new ConstantElements();
		this.pNumeric_Literal = new Numeric_LiteralElements();
		this.pInt_Literal = new Int_LiteralElements();
		this.pSigned_Int = new Signed_IntElements();
		this.pArray_Size = new Array_SizeElements();
		this.pReal_Literal = new Real_LiteralElements();
		this.pReal_Value = new Real_ValueElements();
		this.pBool_Literal = new Bool_LiteralElements();
		this.pBool_Value = new Bool_ValueElements();
		this.pChar_Literal = new Char_LiteralElements();
		this.pTime_Literal = new Time_LiteralElements();
		this.pDuration = new DurationElements();
		this.pDuration_Value = new Duration_ValueElements();
		this.eDuration_Unit = new Duration_UnitElements();
		this.pFix_Point = new Fix_PointElements();
		this.pTime_Of_Day = new Time_Of_DayElements();
		this.pDaytime = new DaytimeElements();
		this.pDay_Hour = new Day_HourElements();
		this.pDay_Minute = new Day_MinuteElements();
		this.pDay_Second = new Day_SecondElements();
		this.pDate = new DateElements();
		this.pDate_Literal = new Date_LiteralElements();
		this.pYear = new YearElements();
		this.pMonth = new MonthElements();
		this.pDay = new DayElements();
		this.pDate_And_Time = new Date_And_TimeElements();
		this.pDate_And_Time_Value = new Date_And_Time_ValueElements();
		this.pType_Name = new Type_NameElements();
		this.eInt_Type_Name = new Int_Type_NameElements();
		this.eReal_Type_Name = new Real_Type_NameElements();
		this.eString_Type_Name = new String_Type_NameElements();
		this.eTime_Type_Name = new Time_Type_NameElements();
		this.eTod_Type_Name = new Tod_Type_NameElements();
		this.eDate_Type_Name = new Date_Type_NameElements();
		this.eDT_Type_Name = new DT_Type_NameElements();
		this.eBool_Type_Name = new Bool_Type_NameElements();
		this.eAny_Bit_Type_Name = new Any_Bit_Type_NameElements();
		this.tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.LETTER");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.DIGIT");
		this.tBIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.BIT");
		this.tOCTAL_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.OCTAL_DIGIT");
		this.tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.HEX_DIGIT");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.ID");
		this.tBINARY_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.BINARY_INT");
		this.tOCTAL_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.OCTAL_INT");
		this.tHEX_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.HEX_INT");
		this.tUNSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.UNSIGNED_INT");
		this.tS_BYTE_CHAR_STR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.S_BYTE_CHAR_STR");
		this.tD_BYTE_CHAR_STR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.D_BYTE_CHAR_STR");
		this.tS_BYTE_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.S_BYTE_CHAR_VALUE");
		this.tD_BYTE_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.D_BYTE_CHAR_VALUE");
		this.tCOMMON_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.COMMON_CHAR_VALUE");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.model.structuredtext.StructuredText.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.fordiac.ide.model.structuredtext.StructuredText".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//StructuredTextAlgorithm:
	//	{StructuredTextAlgorithm} ('VAR' (localVariables+=Var_Decl_Init ';')*
	//	'END_VAR')?
	//	statements=Stmt_List;
	public StructuredTextAlgorithmElements getStructuredTextAlgorithmAccess() {
		return pStructuredTextAlgorithm;
	}
	
	public ParserRule getStructuredTextAlgorithmRule() {
		return getStructuredTextAlgorithmAccess().getRule();
	}
	
	//Var_Decl_Init libraryElement::VarDeclaration:
	//	{LocalVariable} constant?='CONSTANT'? name=ID ':'
	//	type=[datatype::DataType|Type_Name] (array?='[' arraySize=Array_Size ']')? (':=' initialValue=Constant)?;
	public Var_Decl_InitElements getVar_Decl_InitAccess() {
		return pVar_Decl_Init;
	}
	
	public ParserRule getVar_Decl_InitRule() {
		return getVar_Decl_InitAccess().getRule();
	}
	
	///************************************************************************
	//								statement
	//************************************************************************/ Stmt_List StatementList:
	//	{StatementList} (statements+=Stmt? ';')*;
	public Stmt_ListElements getStmt_ListAccess() {
		return pStmt_List;
	}
	
	public ParserRule getStmt_ListRule() {
		return getStmt_ListAccess().getRule();
	}
	
	//Stmt Statement:
	//	Assign_Stmt | Subprog_Ctrl_Stmt | Selection_Stmt | Iteration_Stmt;
	public StmtElements getStmtAccess() {
		return pStmt;
	}
	
	public ParserRule getStmtRule() {
		return getStmtAccess().getRule();
	}
	
	//Assign_Stmt AssignmentStatement:
	//	variable=Variable ':='
	//	expression=Expression;
	public Assign_StmtElements getAssign_StmtAccess() {
		return pAssign_Stmt;
	}
	
	public ParserRule getAssign_StmtRule() {
		return getAssign_StmtAccess().getRule();
	}
	
	//Subprog_Ctrl_Stmt Statement:
	//	Func_Call | {SuperStatement} 'SUPER' '(' ')' | {ReturnStatement} 'RETURN';
	public Subprog_Ctrl_StmtElements getSubprog_Ctrl_StmtAccess() {
		return pSubprog_Ctrl_Stmt;
	}
	
	public ParserRule getSubprog_Ctrl_StmtRule() {
		return getSubprog_Ctrl_StmtAccess().getRule();
	}
	
	//Selection_Stmt Statement:
	//	IF_Stmt | Case_Stmt;
	public Selection_StmtElements getSelection_StmtAccess() {
		return pSelection_Stmt;
	}
	
	public ParserRule getSelection_StmtRule() {
		return getSelection_StmtAccess().getRule();
	}
	
	//IF_Stmt IfStatement:
	//	'IF' expression=Expression 'THEN'
	//	statments=Stmt_List
	//	elseif+=ELSIF_Clause*
	//	else=ELSE_Clause?
	//	'END_IF';
	public IF_StmtElements getIF_StmtAccess() {
		return pIF_Stmt;
	}
	
	public ParserRule getIF_StmtRule() {
		return getIF_StmtAccess().getRule();
	}
	
	//ELSIF_Clause ElseIfClause:
	//	'ELSIF' expression=Expression 'THEN'
	//	statements=Stmt_List;
	public ELSIF_ClauseElements getELSIF_ClauseAccess() {
		return pELSIF_Clause;
	}
	
	public ParserRule getELSIF_ClauseRule() {
		return getELSIF_ClauseAccess().getRule();
	}
	
	//ELSE_Clause ElseClause:
	//	'ELSE'
	//	statements=Stmt_List;
	public ELSE_ClauseElements getELSE_ClauseAccess() {
		return pELSE_Clause;
	}
	
	public ParserRule getELSE_ClauseRule() {
		return getELSE_ClauseAccess().getRule();
	}
	
	//Case_Stmt CaseStatement:
	//	'CASE' expression=Expression 'OF'
	//	case+=Case_Selection+
	//	else=ELSE_Clause?
	//	'END_CASE';
	public Case_StmtElements getCase_StmtAccess() {
		return pCase_Stmt;
	}
	
	public ParserRule getCase_StmtRule() {
		return getCase_StmtAccess().getRule();
	}
	
	//Case_Selection CaseClause:
	//	case+=Constant (',' case+=Constant)* ':' //only allow explicit constants here
	//	statements=Stmt_List;
	public Case_SelectionElements getCase_SelectionAccess() {
		return pCase_Selection;
	}
	
	public ParserRule getCase_SelectionRule() {
		return getCase_SelectionAccess().getRule();
	}
	
	//Iteration_Stmt Statement:
	//	For_Stmt | While_Stmt | Repeat_Stmt | {ExitStatement} 'EXIT' | {ContinueStatement} 'CONTINUE';
	public Iteration_StmtElements getIteration_StmtAccess() {
		return pIteration_Stmt;
	}
	
	public ParserRule getIteration_StmtRule() {
		return getIteration_StmtAccess().getRule();
	}
	
	//For_Stmt ForStatement:
	//	'FOR' variable=Variable_Primary ':=' from=Expression 'TO' to=Expression ('BY' by=Expression)? 'DO'
	//	statements=Stmt_List
	//	'END_FOR';
	public For_StmtElements getFor_StmtAccess() {
		return pFor_Stmt;
	}
	
	public ParserRule getFor_StmtRule() {
		return getFor_StmtAccess().getRule();
	}
	
	//While_Stmt WhileStatement:
	//	'WHILE' expression=Expression 'DO'
	//	statements=Stmt_List
	//	'END_WHILE';
	public While_StmtElements getWhile_StmtAccess() {
		return pWhile_Stmt;
	}
	
	public ParserRule getWhile_StmtRule() {
		return getWhile_StmtAccess().getRule();
	}
	
	//Repeat_Stmt RepeatStatement:
	//	'REPEAT'
	//	statements=Stmt_List
	//	'UNTIL' expression=Expression
	//	'END_REPEAT';
	public Repeat_StmtElements getRepeat_StmtAccess() {
		return pRepeat_Stmt;
	}
	
	public ParserRule getRepeat_StmtRule() {
		return getRepeat_StmtAccess().getRule();
	}
	
	///************************************************************************
	//								expression
	//************************************************************************/ Expression:
	//	Or_Expression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//enum Or_Operator returns BinaryOperator:
	//	OR;
	public Or_OperatorElements getOr_OperatorAccess() {
		return eOr_Operator;
	}
	
	public EnumRule getOr_OperatorRule() {
		return getOr_OperatorAccess().getRule();
	}
	
	//Or_Expression Expression:
	//	Xor_Expr ({BinaryExpression.left=current} operator=Or_Operator right=Xor_Expr)*;
	public Or_ExpressionElements getOr_ExpressionAccess() {
		return pOr_Expression;
	}
	
	public ParserRule getOr_ExpressionRule() {
		return getOr_ExpressionAccess().getRule();
	}
	
	//enum Xor_Operator returns BinaryOperator:
	//	XOR;
	public Xor_OperatorElements getXor_OperatorAccess() {
		return eXor_Operator;
	}
	
	public EnumRule getXor_OperatorRule() {
		return getXor_OperatorAccess().getRule();
	}
	
	//Xor_Expr Expression:
	//	And_Expr ({BinaryExpression.left=current} operator=Xor_Operator right=And_Expr)*;
	public Xor_ExprElements getXor_ExprAccess() {
		return pXor_Expr;
	}
	
	public ParserRule getXor_ExprRule() {
		return getXor_ExprAccess().getRule();
	}
	
	//enum And_Operator returns BinaryOperator:
	//	AND | AND='&';
	public And_OperatorElements getAnd_OperatorAccess() {
		return eAnd_Operator;
	}
	
	public EnumRule getAnd_OperatorRule() {
		return getAnd_OperatorAccess().getRule();
	}
	
	//And_Expr Expression:
	//	Compare_Expr ({BinaryExpression.left=current} operator=And_Operator right=Compare_Expr)*;
	public And_ExprElements getAnd_ExprAccess() {
		return pAnd_Expr;
	}
	
	public ParserRule getAnd_ExprRule() {
		return getAnd_ExprAccess().getRule();
	}
	
	//enum Compare_Operator returns BinaryOperator:
	//	EQ='=' | NE='<>';
	public Compare_OperatorElements getCompare_OperatorAccess() {
		return eCompare_Operator;
	}
	
	public EnumRule getCompare_OperatorRule() {
		return getCompare_OperatorAccess().getRule();
	}
	
	//Compare_Expr Expression:
	//	Equ_Expr ({BinaryExpression.left=current} operator=Compare_Operator right=Equ_Expr)*;
	public Compare_ExprElements getCompare_ExprAccess() {
		return pCompare_Expr;
	}
	
	public ParserRule getCompare_ExprRule() {
		return getCompare_ExprAccess().getRule();
	}
	
	//enum Equ_Operator returns BinaryOperator:
	//	LT='<' | LE='<=' | GT='>' | GE='>=';
	public Equ_OperatorElements getEqu_OperatorAccess() {
		return eEqu_Operator;
	}
	
	public EnumRule getEqu_OperatorRule() {
		return getEqu_OperatorAccess().getRule();
	}
	
	//Equ_Expr Expression:
	//	Add_Expr ({BinaryExpression.left=current} operator=Equ_Operator right=Add_Expr)*;
	public Equ_ExprElements getEqu_ExprAccess() {
		return pEqu_Expr;
	}
	
	public ParserRule getEqu_ExprRule() {
		return getEqu_ExprAccess().getRule();
	}
	
	//enum Add_Operator returns BinaryOperator:
	//	ADD='+' | SUB='-';
	public Add_OperatorElements getAdd_OperatorAccess() {
		return eAdd_Operator;
	}
	
	public EnumRule getAdd_OperatorRule() {
		return getAdd_OperatorAccess().getRule();
	}
	
	//Add_Expr Expression:
	//	Term ({BinaryExpression.left=current} operator=Add_Operator right=Term)*;
	public Add_ExprElements getAdd_ExprAccess() {
		return pAdd_Expr;
	}
	
	public ParserRule getAdd_ExprRule() {
		return getAdd_ExprAccess().getRule();
	}
	
	//enum Term_Operator returns BinaryOperator:
	//	MUL='*' | DIV='/' | MOD;
	public Term_OperatorElements getTerm_OperatorAccess() {
		return eTerm_Operator;
	}
	
	public EnumRule getTerm_OperatorRule() {
		return getTerm_OperatorAccess().getRule();
	}
	
	//Term Expression:
	//	Power_Expr ({BinaryExpression.left=current} operator=Term_Operator right=Power_Expr)*;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//enum Power_Operator returns BinaryOperator:
	//	POWER='**';
	public Power_OperatorElements getPower_OperatorAccess() {
		return ePower_Operator;
	}
	
	public EnumRule getPower_OperatorRule() {
		return getPower_OperatorAccess().getRule();
	}
	
	//Power_Expr Expression:
	//	Unary_Expr ({BinaryExpression.left=current} operator=Power_Operator right=Unary_Expr)*;
	public Power_ExprElements getPower_ExprAccess() {
		return pPower_Expr;
	}
	
	public ParserRule getPower_ExprRule() {
		return getPower_ExprAccess().getRule();
	}
	
	//enum Unary_Operator returns UnaryOperator:
	//	MINUS='-' | PLUS='+' | NOT;
	public Unary_OperatorElements getUnary_OperatorAccess() {
		return eUnary_Operator;
	}
	
	public EnumRule getUnary_OperatorRule() {
		return getUnary_OperatorAccess().getRule();
	}
	
	//Unary_Expr Expression:
	//	{UnaryExpression} operator=Unary_Operator expression=Primary_Expr | Primary_Expr | Constant // handle Constant here to avoid ambiguity with '+' and '-' operators
	//;
	public Unary_ExprElements getUnary_ExprAccess() {
		return pUnary_Expr;
	}
	
	public ParserRule getUnary_ExprRule() {
		return getUnary_ExprAccess().getRule();
	}
	
	//Primary_Expr Expression:
	//	Variable | Func_Call | /*Ref_Value |*/ '(' Expression ')';
	public Primary_ExprElements getPrimary_ExprAccess() {
		return pPrimary_Expr;
	}
	
	public ParserRule getPrimary_ExprRule() {
		return getPrimary_ExprAccess().getRule();
	}
	
	//Func_Call Call:
	//	func=(ID | 'TIME') // also allow 'TIME' as function name
	//	'(' (args+=Param_Assign (',' args+=Param_Assign)*)? ')';
	public Func_CallElements getFunc_CallAccess() {
		return pFunc_Call;
	}
	
	public ParserRule getFunc_CallRule() {
		return getFunc_CallAccess().getRule();
	}
	
	//Param_Assign Argument:
	//	Param_Assign_In | Param_Assign_Out;
	public Param_AssignElements getParam_AssignAccess() {
		return pParam_Assign;
	}
	
	public ParserRule getParam_AssignRule() {
		return getParam_AssignAccess().getRule();
	}
	
	//Param_Assign_In InArgument:
	//	(var=ID ':=')? expr=Expression;
	public Param_Assign_InElements getParam_Assign_InAccess() {
		return pParam_Assign_In;
	}
	
	public ParserRule getParam_Assign_InRule() {
		return getParam_Assign_InAccess().getRule();
	}
	
	//Param_Assign_Out OutArgument:
	//	not?='NOT'? var=ID '=>' expr=Variable;
	public Param_Assign_OutElements getParam_Assign_OutAccess() {
		return pParam_Assign_Out;
	}
	
	public ParserRule getParam_Assign_OutRule() {
		return getParam_Assign_OutAccess().getRule();
	}
	
	//Variable:
	//	Variable_Subscript;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//Variable_Subscript Variable:
	//	(Variable_Primary | Variable_Adapter) ({ArrayVariable.array=current} '[' index+=Expression (',' index+=Expression)*
	//	']')?;
	public Variable_SubscriptElements getVariable_SubscriptAccess() {
		return pVariable_Subscript;
	}
	
	public ParserRule getVariable_SubscriptRule() {
		return getVariable_SubscriptAccess().getRule();
	}
	
	//Variable_Adapter Variable:
	//	{AdapterVariable} adapter=[libraryElement::AdapterDeclaration|Adapter_Name] '.'
	//	var=[libraryElement::VarDeclaration|Variable_Name];
	public Variable_AdapterElements getVariable_AdapterAccess() {
		return pVariable_Adapter;
	}
	
	public ParserRule getVariable_AdapterRule() {
		return getVariable_AdapterAccess().getRule();
	}
	
	//Adapter_Name:
	//	ID | 'T' | 'LT' | 'DT';
	public Adapter_NameElements getAdapter_NameAccess() {
		return pAdapter_Name;
	}
	
	public ParserRule getAdapter_NameRule() {
		return getAdapter_NameAccess().getRule();
	}
	
	//Variable_Primary PrimaryVariable:
	//	var=[libraryElement::VarDeclaration|Variable_Name];
	public Variable_PrimaryElements getVariable_PrimaryAccess() {
		return pVariable_Primary;
	}
	
	public ParserRule getVariable_PrimaryRule() {
		return getVariable_PrimaryAccess().getRule();
	}
	
	//Variable_Name:
	//	ID | 'T' | 'LT' | 'DT';
	public Variable_NameElements getVariable_NameAccess() {
		return pVariable_Name;
	}
	
	public ParserRule getVariable_NameRule() {
		return getVariable_NameAccess().getRule();
	}
	
	///************************************************************************
	//								literals
	//*************************************************************************/ Constant:
	//	Numeric_Literal | Char_Literal | Time_Literal | Bool_Literal;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//Numeric_Literal NumericLiteral:
	//	Int_Literal | Real_Literal;
	public Numeric_LiteralElements getNumeric_LiteralAccess() {
		return pNumeric_Literal;
	}
	
	public ParserRule getNumeric_LiteralRule() {
		return getNumeric_LiteralAccess().getRule();
	}
	
	//Int_Literal IntLiteral:
	//	(type=Int_Type_Name '#')?
	//	value=(Signed_Int | BINARY_INT | OCTAL_INT | HEX_INT);
	public Int_LiteralElements getInt_LiteralAccess() {
		return pInt_Literal;
	}
	
	public ParserRule getInt_LiteralRule() {
		return getInt_LiteralAccess().getRule();
	}
	
	//Signed_Int ecore::ELong:
	//	('+' | '-')? UNSIGNED_INT;
	public Signed_IntElements getSigned_IntAccess() {
		return pSigned_Int;
	}
	
	public ParserRule getSigned_IntRule() {
		return getSigned_IntAccess().getRule();
	}
	
	//Array_Size ecore::EInt:
	//	UNSIGNED_INT;
	public Array_SizeElements getArray_SizeAccess() {
		return pArray_Size;
	}
	
	public ParserRule getArray_SizeRule() {
		return getArray_SizeAccess().getRule();
	}
	
	//Real_Literal RealLiteral:
	//	(type=Real_Type_Name '#')?
	//	value=Real_Value;
	public Real_LiteralElements getReal_LiteralAccess() {
		return pReal_Literal;
	}
	
	public ParserRule getReal_LiteralRule() {
		return getReal_LiteralAccess().getRule();
	}
	
	//Real_Value ecore::EDouble:
	//	Signed_Int '.' UNSIGNED_INT ('E' Signed_Int)?;
	public Real_ValueElements getReal_ValueAccess() {
		return pReal_Value;
	}
	
	public ParserRule getReal_ValueRule() {
		return getReal_ValueAccess().getRule();
	}
	
	//Bool_Literal BoolLiteral:
	//	(type=Bool_Type_Name '#')?
	//	value=Bool_Value;
	public Bool_LiteralElements getBool_LiteralAccess() {
		return pBool_Literal;
	}
	
	public ParserRule getBool_LiteralRule() {
		return getBool_LiteralAccess().getRule();
	}
	
	//Bool_Value ecore::EBoolean:
	//	'FALSE' | 'TRUE' // cannot distinguish '0' and '1' from Int_Literal
	//;
	public Bool_ValueElements getBool_ValueAccess() {
		return pBool_Value;
	}
	
	public ParserRule getBool_ValueRule() {
		return getBool_ValueAccess().getRule();
	}
	
	//Char_Literal StringLiteral:
	//	(type=String_Type_Name length=UNSIGNED_INT? '#')?
	//	value=(S_BYTE_CHAR_STR | D_BYTE_CHAR_STR);
	public Char_LiteralElements getChar_LiteralAccess() {
		return pChar_Literal;
	}
	
	public ParserRule getChar_LiteralRule() {
		return getChar_LiteralAccess().getRule();
	}
	
	//Time_Literal TimeLiteral:
	//	Duration | Time_Of_Day | Date | Date_And_Time;
	public Time_LiteralElements getTime_LiteralAccess() {
		return pTime_Literal;
	}
	
	public ParserRule getTime_LiteralRule() {
		return getTime_LiteralAccess().getRule();
	}
	
	//Duration DurationLiteral:
	//	type=Time_Type_Name '#' ('+' | negative?='-')?
	//	value+=Duration_Value ('_' value+=Duration_Value)*;
	public DurationElements getDurationAccess() {
		return pDuration;
	}
	
	public ParserRule getDurationRule() {
		return getDurationAccess().getRule();
	}
	
	//Duration_Value DurationValue:
	//	value=Fix_Point
	//	unit=Duration_Unit;
	public Duration_ValueElements getDuration_ValueAccess() {
		return pDuration_Value;
	}
	
	public ParserRule getDuration_ValueRule() {
		return getDuration_ValueAccess().getRule();
	}
	
	//enum Duration_Unit:
	//	DAYS='d' | HOURS='h' | MINUTES='m' | SECONDS='s' | MILLIS='ms' | MICROS='us' | NANOS='ns';
	public Duration_UnitElements getDuration_UnitAccess() {
		return eDuration_Unit;
	}
	
	public EnumRule getDuration_UnitRule() {
		return getDuration_UnitAccess().getRule();
	}
	
	//Fix_Point:
	//	UNSIGNED_INT ('.' UNSIGNED_INT)?;
	public Fix_PointElements getFix_PointAccess() {
		return pFix_Point;
	}
	
	public ParserRule getFix_PointRule() {
		return getFix_PointAccess().getRule();
	}
	
	//Time_Of_Day DateLiteral:
	//	type=Tod_Type_Name '#'
	//	value=Daytime;
	public Time_Of_DayElements getTime_Of_DayAccess() {
		return pTime_Of_Day;
	}
	
	public ParserRule getTime_Of_DayRule() {
		return getTime_Of_DayAccess().getRule();
	}
	
	//Daytime ecore::EDate:
	//	Day_Hour ':' Day_Minute ':' Day_Second;
	public DaytimeElements getDaytimeAccess() {
		return pDaytime;
	}
	
	public ParserRule getDaytimeRule() {
		return getDaytimeAccess().getRule();
	}
	
	//Day_Hour:
	//	UNSIGNED_INT;
	public Day_HourElements getDay_HourAccess() {
		return pDay_Hour;
	}
	
	public ParserRule getDay_HourRule() {
		return getDay_HourAccess().getRule();
	}
	
	//Day_Minute:
	//	UNSIGNED_INT;
	public Day_MinuteElements getDay_MinuteAccess() {
		return pDay_Minute;
	}
	
	public ParserRule getDay_MinuteRule() {
		return getDay_MinuteAccess().getRule();
	}
	
	//Day_Second:
	//	Fix_Point;
	public Day_SecondElements getDay_SecondAccess() {
		return pDay_Second;
	}
	
	public ParserRule getDay_SecondRule() {
		return getDay_SecondAccess().getRule();
	}
	
	//Date DateLiteral:
	//	type=Date_Type_Name '#'
	//	value=Date_Literal;
	public DateElements getDateAccess() {
		return pDate;
	}
	
	public ParserRule getDateRule() {
		return getDateAccess().getRule();
	}
	
	//Date_Literal ecore::EDate:
	//	Year '-' Month '-' Day;
	public Date_LiteralElements getDate_LiteralAccess() {
		return pDate_Literal;
	}
	
	public ParserRule getDate_LiteralRule() {
		return getDate_LiteralAccess().getRule();
	}
	
	//Year:
	//	UNSIGNED_INT;
	public YearElements getYearAccess() {
		return pYear;
	}
	
	public ParserRule getYearRule() {
		return getYearAccess().getRule();
	}
	
	//Month:
	//	UNSIGNED_INT;
	public MonthElements getMonthAccess() {
		return pMonth;
	}
	
	public ParserRule getMonthRule() {
		return getMonthAccess().getRule();
	}
	
	//Day:
	//	UNSIGNED_INT;
	public DayElements getDayAccess() {
		return pDay;
	}
	
	public ParserRule getDayRule() {
		return getDayAccess().getRule();
	}
	
	//Date_And_Time DateLiteral:
	//	type=DT_Type_Name '#'
	//	value=Date_And_Time_Value;
	public Date_And_TimeElements getDate_And_TimeAccess() {
		return pDate_And_Time;
	}
	
	public ParserRule getDate_And_TimeRule() {
		return getDate_And_TimeAccess().getRule();
	}
	
	//Date_And_Time_Value ecore::EDate:
	//	Date_Literal '-' Daytime;
	public Date_And_Time_ValueElements getDate_And_Time_ValueAccess() {
		return pDate_And_Time_Value;
	}
	
	public ParserRule getDate_And_Time_ValueRule() {
		return getDate_And_Time_ValueAccess().getRule();
	}
	
	///************************************************************************
	//								type names
	//********************************************************************** */ Type_Name:
	//	ID
	//	| 'DINT' | 'INT' | 'SINT' | 'LINT' //Sign_Int_Type_Name
	//	| 'UINT' | 'USINT' | 'UDINT' | 'ULINT' //Unsign_Int_Type_Name
	//	| 'REAL' | 'LREAL'
	//	| 'STRING' | 'WSTRING' | 'CHAR' | 'WCHAR'
	//	| 'TIME' | 'LTIME'
	//	| 'TIME_OF_DAY' | 'LTIME_OF_DAY' | 'TOD' | 'LTOD' // also allow 'LTIME_OF_DAY'
	//	| 'DATE' | 'LDATE'
	//	| 'DATE_AND_TIME' | 'LDATE_AND_TIME'
	//	| 'BOOL';
	public Type_NameElements getType_NameAccess() {
		return pType_Name;
	}
	
	public ParserRule getType_NameRule() {
		return getType_NameAccess().getRule();
	}
	
	//enum Int_Type_Name returns Type:
	//	DINT | INT | SINT | LINT //Sign_Int_Type_Name
	//	| UINT | USINT | UDINT | ULINT //Unsign_Int_Type_Name
	//;
	public Int_Type_NameElements getInt_Type_NameAccess() {
		return eInt_Type_Name;
	}
	
	public EnumRule getInt_Type_NameRule() {
		return getInt_Type_NameAccess().getRule();
	}
	
	//enum Real_Type_Name returns Type:
	//	REAL | LREAL;
	public Real_Type_NameElements getReal_Type_NameAccess() {
		return eReal_Type_Name;
	}
	
	public EnumRule getReal_Type_NameRule() {
		return getReal_Type_NameAccess().getRule();
	}
	
	//enum String_Type_Name returns Type:
	//	STRING | WSTRING | CHAR | WCHAR;
	public String_Type_NameElements getString_Type_NameAccess() {
		return eString_Type_Name;
	}
	
	public EnumRule getString_Type_NameRule() {
		return getString_Type_NameAccess().getRule();
	}
	
	//enum Time_Type_Name returns Type:
	//	TIME | LTIME | T | LT // also allow short type names
	//;
	public Time_Type_NameElements getTime_Type_NameAccess() {
		return eTime_Type_Name;
	}
	
	public EnumRule getTime_Type_NameRule() {
		return getTime_Type_NameAccess().getRule();
	}
	
	//enum Tod_Type_Name returns Type:
	//	TIME_OF_DAY | LTIME_OF_DAY | TOD | LTOD // also allow 'LTIME_OF_DAY'
	//;
	public Tod_Type_NameElements getTod_Type_NameAccess() {
		return eTod_Type_Name;
	}
	
	public EnumRule getTod_Type_NameRule() {
		return getTod_Type_NameAccess().getRule();
	}
	
	//enum Date_Type_Name returns Type:
	//	DATE | LDATE | D | LD // also allow short type names
	//;
	public Date_Type_NameElements getDate_Type_NameAccess() {
		return eDate_Type_Name;
	}
	
	public EnumRule getDate_Type_NameRule() {
		return getDate_Type_NameAccess().getRule();
	}
	
	//enum DT_Type_Name returns Type:
	//	DATE_AND_TIME | LDATE_AND_TIME | DT | LDT // also allow 'LDATE_AND_TIME'
	//;
	public DT_Type_NameElements getDT_Type_NameAccess() {
		return eDT_Type_Name;
	}
	
	public EnumRule getDT_Type_NameRule() {
		return getDT_Type_NameAccess().getRule();
	}
	
	//enum Bool_Type_Name returns Type:
	//	BOOL;
	public Bool_Type_NameElements getBool_Type_NameAccess() {
		return eBool_Type_Name;
	}
	
	public EnumRule getBool_Type_NameRule() {
		return getBool_Type_NameAccess().getRule();
	}
	
	//enum Any_Bit_Type_Name returns Type:
	//	BYTE | WORD | DWORD | LWORD;
	public Any_Bit_Type_NameElements getAny_Bit_Type_NameAccess() {
		return eAny_Bit_Type_Name;
	}
	
	public EnumRule getAny_Bit_Type_NameRule() {
		return getAny_Bit_Type_NameAccess().getRule();
	}
	
	//terminal fragment LETTER:
	//	'a'..'z' | 'A'..'Z' | '_';
	public TerminalRule getLETTERRule() {
		return tLETTER;
	}
	
	//terminal fragment DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal fragment BIT:
	//	'0'..'1';
	public TerminalRule getBITRule() {
		return tBIT;
	}
	
	//terminal fragment OCTAL_DIGIT:
	//	'0'..'7';
	public TerminalRule getOCTAL_DIGITRule() {
		return tOCTAL_DIGIT;
	}
	
	//terminal fragment HEX_DIGIT:
	//	'0'..'9' | 'a'..'f' | 'A'..'F';
	public TerminalRule getHEX_DIGITRule() {
		return tHEX_DIGIT;
	}
	
	//terminal ID:
	//	LETTER (LETTER | DIGIT)*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal BINARY_INT returns ecore::ELong:
	//	'2#' ('_'? BIT)+;
	public TerminalRule getBINARY_INTRule() {
		return tBINARY_INT;
	}
	
	//terminal OCTAL_INT returns ecore::ELong:
	//	'8#' ('_'? OCTAL_DIGIT)+;
	public TerminalRule getOCTAL_INTRule() {
		return tOCTAL_INT;
	}
	
	//terminal HEX_INT returns ecore::ELong:
	//	'16#' ('_'? HEX_DIGIT)+;
	public TerminalRule getHEX_INTRule() {
		return tHEX_INT;
	}
	
	//terminal UNSIGNED_INT returns ecore::ELong:
	//	DIGIT ('_'? DIGIT)*;
	public TerminalRule getUNSIGNED_INTRule() {
		return tUNSIGNED_INT;
	}
	
	//terminal S_BYTE_CHAR_STR:
	//	'\'' S_BYTE_CHAR_VALUE* '\'';
	public TerminalRule getS_BYTE_CHAR_STRRule() {
		return tS_BYTE_CHAR_STR;
	}
	
	//terminal D_BYTE_CHAR_STR:
	//	'"' D_BYTE_CHAR_VALUE* '"';
	public TerminalRule getD_BYTE_CHAR_STRRule() {
		return tD_BYTE_CHAR_STR;
	}
	
	//terminal fragment S_BYTE_CHAR_VALUE:
	//	COMMON_CHAR_VALUE | '$\'' | '"' | '$' HEX_DIGIT HEX_DIGIT;
	public TerminalRule getS_BYTE_CHAR_VALUERule() {
		return tS_BYTE_CHAR_VALUE;
	}
	
	//terminal fragment D_BYTE_CHAR_VALUE:
	//	COMMON_CHAR_VALUE | '\'' | '$"' | '$' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public TerminalRule getD_BYTE_CHAR_VALUERule() {
		return tD_BYTE_CHAR_VALUE;
	}
	
	//terminal fragment COMMON_CHAR_VALUE:
	//	' ' | '!' | '#' | '%' | '&' | '('..'/' | '0'..'9' | ':'..'@' | 'A'..'Z' | '['..'`' | 'a'..'z' | '{'..'~' | '$$' | '$L'
	//	| '$N' | '$P' | '$R' | '$T';
	public TerminalRule getCOMMON_CHAR_VALUERule() {
		return tCOMMON_CHAR_VALUE;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/' | '(*'->'*)';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
